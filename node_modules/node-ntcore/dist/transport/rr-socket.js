"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const net_1 = require("net");
const log_util_1 = __importDefault(require("../utils/log-util"));
/**
 * Re-targetable, Re-connecting Socket
 *
 * This socket wrapper allows re-targetting (having the same socket object
 * but connecting to a different endpoint), and re-connection (tries to
 * connect over and over)
 */
class RRSocket extends events_1.EventEmitter {
    constructor(options, logger) {
        super();
        this._socketConnected = false;
        this._ident = "";
        this._reconnectTimeoutDelayMs = 1000;
        this._address = "";
        this._port = 0;
        this._reconnectCount = 0;
        if (logger) {
            this._logger = logger;
        }
        else {
            this._logger = log_util_1.default.getLogger("RRSocket");
        }
        if (options) {
            if (options.address !== undefined) {
                this._address = options.address;
            }
            if (options.port !== undefined) {
                this._port = options.port;
            }
            if (options.reconnectDelay !== undefined) {
                this._reconnectTimeoutDelayMs = options.reconnectDelay;
            }
            if (options.ident !== undefined) {
                this._ident = options.ident;
            }
        }
    }
    get address() {
        return this._address;
    }
    set address(val) {
        if (val !== this._address) {
            this._address = val;
            if (this._socketConnected) {
                this.disconnect();
                this.connect();
            }
        }
    }
    get port() {
        return this._port;
    }
    set port(val) {
        if (val !== this._port) {
            this._port = val;
            if (this._socketConnected) {
                this.disconnect();
                this.connect();
            }
        }
    }
    get connected() {
        return this._socketConnected;
    }
    setNetworkEndpoint(endpoint, forceReconnect = false) {
        if (forceReconnect || endpoint.address !== this._address || endpoint.port !== this._port) {
            this._address = endpoint.address;
            this._port = endpoint.port;
            if (this._socketConnected) {
                this.disconnect();
                this.connect();
            }
        }
    }
    connect() {
        if (this._socketConnected) {
            return;
        }
        if (this._socket) {
            this._socket.removeAllListeners();
        }
        this._socket = new net_1.Socket();
        this._hookupEvents();
        this._doConnect();
    }
    disconnect() {
        clearTimeout(this._reconnectTimeoutHandle);
        if (!this._socketConnected) {
            this._logger.info(`[${this._ident}] socket not connected during disconnect`);
            return;
        }
        if (this._socket) {
            this._socket.removeAllListeners();
            this._socket.end(() => {
                this._logger.info("TCP Socket disconnected");
            });
            this._socketConnected = false;
            this.emit("close", false);
            this._socket = undefined;
            this._socketConnected = false;
        }
    }
    write(data) {
        if (!this._socketConnected) {
            return Promise.resolve();
        }
        return new Promise(resolve => {
            this._socket.write(data, () => {
                resolve();
            });
        });
    }
    _hookupEvents() {
        this._socket.on("data", data => {
            this.emit("data", data);
        });
        this._socket.on("close", (hadError) => {
            if (this._socketConnected) {
                this.emit("close", false);
                // We were previously connected, therefore this must
                // be a disconnection and we should try to reconnect
                this._attemptReconnect();
            }
            this._socketConnected = false;
        });
        this._socket.on("error", err => {
            if (err.message.indexOf("ECONNREFUSED") !== -1 ||
                err.message.indexOf("ECONNRESET") !== -1) {
                if (this._socketConnected) {
                    this.emit("close", true);
                }
                this._socketConnected = false;
                this._attemptReconnect();
            }
        });
        this._socket.on("end", () => {
            this._socket.end();
            this.emit("close", false);
            this._socketConnected = false;
            this._attemptReconnect();
        });
    }
    _attemptReconnect() {
        clearTimeout(this._reconnectTimeoutHandle);
        this._reconnectTimeoutHandle = setTimeout(() => {
            this._reconnectCount++;
            this._logger.debug(`Reconnecting to ${this._address}:${this._port} (Socket Closed)`);
            if (this._reconnectCount % 10 === 0) {
                this._logger.info(`${this._reconnectCount} reconnect attempt(s) so far...`);
            }
            this.emit("reconnectAttempt");
            this.connect();
        }, this._reconnectTimeoutDelayMs);
    }
    _doConnect() {
        this._socket.connect(this._port, this._address, () => {
            this._socketConnected = true;
            this._logger.info(`Socket connected to ${this._address}:${this._port}`);
            this.emit("connected");
            this._reconnectCount = 0;
        });
    }
}
exports.default = RRSocket;
//# sourceMappingURL=rr-socket.js.map