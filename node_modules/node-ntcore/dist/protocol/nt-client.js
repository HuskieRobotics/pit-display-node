"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const rr_socket_1 = __importDefault(require("../transport/rr-socket"));
const nt_participant_1 = __importDefault(require("./nt-participant"));
const nt_types_1 = require("./nt-types");
class NTClient extends nt_participant_1.default {
    constructor(version, options = { address: "localhost", port: 1735 }) {
        super(options);
        this._version = version;
        this._socket = new rr_socket_1.default({
            address: options.address,
            port: options.port,
            ident: "NTCORE-SOCKET"
        }, this._logger);
        // Hookup events
        this._socket.on("connected", () => __awaiter(this, void 0, void 0, function* () {
            this._logger.debug("TCP socket connected. Initiating handshake");
            // The "connected" event represents that the transport layer
            // (i.e. TCP) is now connected. We can initiate handshaking
            try {
                this._setConnectionState(nt_types_1.NTConnectionState.NTCONN_CONNECTING);
                yield this._handshake();
                this._setConnectionState(nt_types_1.NTConnectionState.NTCONN_CONNECTED);
                this._logger.info(`NT Connection established to ${this._socket.address}:${this._socket.port}`);
            }
            catch (err) {
                this._setConnectionState(nt_types_1.NTConnectionState.NTCONN_NOT_CONNECTED);
                if (err instanceof nt_types_1.NTProtocolVersionUnsupportedError) {
                    this._logger.warn(`Unsupported version requested. Server supports ${err.serverSupportedVersion.major}.${err.serverSupportedVersion.minor}`);
                }
                // Re-throw the error
                throw err;
            }
        }));
        this._socket.on("data", (data) => {
            this._handleData(data);
        });
        this._socket.on("close", () => {
            this._logger.info("NT Connection lost");
            this._setConnectionState(nt_types_1.NTConnectionState.NTCONN_NOT_CONNECTED);
        });
    }
    get connected() {
        return this._currState === nt_types_1.NTConnectionState.NTCONN_CONNECTED;
    }
    set address(val) {
        this._socket.address = val;
    }
    get address() {
        return this._socket.address;
    }
    set port(val) {
        this._socket.port = val;
    }
    get port() {
        return this._socket.port;
    }
    setServerEndpoint(endpoint, forceReconnect = false) {
        this._socket.setNetworkEndpoint(endpoint, forceReconnect);
    }
    start() {
        this._socket.connect();
    }
    stop() {
        this._setConnectionState(nt_types_1.NTConnectionState.NTCONN_NOT_CONNECTED);
        this._socket.disconnect();
    }
    _write(data, immediate = false) {
        // TODO Buffer
        return this._socket.write(data);
    }
}
exports.default = NTClient;
//# sourceMappingURL=nt-client.js.map