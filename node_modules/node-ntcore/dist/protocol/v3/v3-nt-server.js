"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NTClientConnection = void 0;
const events_1 = require("events");
const v3_types_1 = require("./v3-types");
const nt_types_1 = require("../nt-types");
const nt_entry_1 = require("../nt-entry");
const nt_server_1 = __importDefault(require("../nt-server"));
const v3_messages_1 = require("./v3-messages");
const protocol_utils_1 = require("../protocol-utils");
const log_util_1 = __importDefault(require("../../utils/log-util"));
class NTClientConnection extends events_1.EventEmitter {
    constructor(socket, serverIdent, serverEntries, logger) {
        super();
        this._pendingMessages = [];
        this._logger = logger;
        this._socket = socket;
        this._serverEntries = serverEntries;
        this._socket.on("data", (data) => {
            this._handleData(data);
        });
        this._socket.on("close", () => {
            this.emit("connectionClosed");
        });
    }
    write(data) {
        this._socket.write(data);
    }
    _handleData(data) {
        if (!this._dataBuffer) {
            this._dataBuffer = Buffer.allocUnsafe(data.length);
            data.copy(this._dataBuffer, 0, 0);
        }
        else {
            this._dataBuffer = Buffer.concat([
                this._dataBuffer,
                data
            ]);
        }
        let nextMessageResult;
        while (nextMessageResult = v3_messages_1.getNextAvailableMessage(this._rpcDefinitions, this._dataBuffer)) {
            this._pendingMessages.push(nextMessageResult.message);
            this._dataBuffer = Buffer.from(this._dataBuffer.slice(nextMessageResult.newOffset));
        }
        let lastMessage;
        while (this._pendingMessages.length > 0) {
            lastMessage = this._pendingMessages.shift();
            switch (lastMessage.type) {
                case v3_types_1.V3MessageType.CLIENT_HELLO:
                    {
                        // Client HELLO. Write the Server hello and all messages we have
                        this.write(v3_messages_1.serverHelloMessageToBuffer({
                            type: v3_types_1.V3MessageType.SERVER_HELLO,
                            clientPreviouslySeen: false,
                            serverIdentity: ""
                        }));
                        this._serverEntries.forEach(entry => {
                            this.write(v3_messages_1.entryAssignmentMessageToBuffer({
                                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                                entryName: entry.name,
                                entryId: entry.id,
                                entrySeq: entry.seq,
                                entryType: v3_types_1.NTtoV3EntryType.get(entry.type),
                                entryValue: entry.value,
                                entryFlags: entry.flags
                            }));
                        });
                        this.write(v3_messages_1.serverHelloCompleteMessageToBuffer());
                    }
                    break;
                case v3_types_1.V3MessageType.ENTRY_ASSIGNMENT:
                    {
                        this.emit("entryAssignment", lastMessage);
                    }
                    break;
                case v3_types_1.V3MessageType.ENTRY_UPDATE:
                    {
                        this.emit("entryUpdate", lastMessage);
                    }
                    break;
                case v3_types_1.V3MessageType.ENTRY_FLAGS_UPDATE:
                    {
                        this.emit("entryFlagsUpdate", lastMessage);
                    }
                    break;
                case v3_types_1.V3MessageType.ENTRY_DELETE: {
                    this.emit("entryDelete", lastMessage);
                }
                case v3_types_1.V3MessageType.CLEAR_ALL_ENTRIES:
                    {
                        this.emit("clearAllEntries", lastMessage);
                    }
                    break;
                case v3_types_1.V3MessageType.RPC_EXECUTE:
                    {
                        this.emit("rpcExecute", lastMessage);
                    }
                    break;
                case v3_types_1.V3MessageType.KEEP_ALIVE:
                    break;
                case v3_types_1.V3MessageType.CLIENT_HELLO_COMPLETE:
                    break;
                default: {
                    this._logger.debug(`Dropping ${v3_types_1.V3MessageTypeToString.get(lastMessage.type)} message (not handled)`);
                }
            }
        }
    }
}
exports.NTClientConnection = NTClientConnection;
class V3NTServer extends nt_server_1.default {
    constructor(options) {
        super({ major: 3, minor: 0 }, options);
        this._connections = [];
        this._entryNameToId = new Map();
        this._entries = new Map();
        this._rpcDefinitions = new Map();
        this._nextId = 0;
        this._logger = log_util_1.default.getLogger("NTCORE-SERVER-V3");
    }
    setBoolean(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.BOOLEAN,
            name: key,
            value: {
                bool: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getBoolean(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.BOOLEAN).value.bool;
    }
    setDouble(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.DOUBLE,
            name: key,
            value: {
                double: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getDouble(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.DOUBLE).value.double;
    }
    setString(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.STRING,
            name: key,
            value: {
                str: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getString(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.STRING).value.str;
    }
    setBooleanArray(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.BOOLEAN_ARRAY,
            name: key,
            value: {
                bool_array: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getBooleanArray(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.BOOLEAN_ARRAY).value.bool_array;
    }
    setDoubleArray(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.DOUBLE_ARRAY,
            name: key,
            value: {
                double_array: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getDoubleArray(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.DOUBLE_ARRAY).value.double_array;
    }
    setStringArray(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.STRING_ARRAY,
            name: key,
            value: {
                str_array: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getStringArray(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.STRING_ARRAY).value.str_array;
    }
    setRaw(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.RAW,
            name: key,
            value: {
                raw: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getRaw(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.RAW).value.raw;
    }
    deleteEntry(key) {
        if (this._entryNameToId.has(key)) {
            const entryId = this._entryNameToId.get(key);
            const entry = this._entries.get(entryId);
            this._entries.delete(entryId);
            this._entryNameToId.delete(key);
            this._broadcast(null, v3_messages_1.entryDeleteMessageToBuffer({
                type: v3_types_1.V3MessageType.ENTRY_DELETE,
                entryId
            }));
            this.emit("entryDeleted", {
                source: nt_types_1.NTEventUpdateSource.LOCAL,
                entry: Object.assign({}, entry)
            });
            return true;
        }
        return false;
    }
    updateEntryFlags(key, flags) {
        if (this._entryNameToId.has(key)) {
            const entryId = this._entryNameToId.get(key);
            const entry = this._entries.get(entryId);
            entry.flags = flags;
            this._broadcast(null, v3_messages_1.entryFlagsUpdateMessageToBuffer({
                type: v3_types_1.V3MessageType.ENTRY_FLAGS_UPDATE,
                entryId,
                entryFlags: entry.flags
            }));
            this.emit("entryFlagsUpdated", {
                source: nt_types_1.NTEventUpdateSource.LOCAL,
                entry: Object.assign({}, entry)
            });
            return true;
        }
        return false;
    }
    _onSocketConnected(socket) {
        const conn = new NTClientConnection(socket, this._identifier, this._entries, this._logger);
        this._connections.push(conn);
        conn.on("connectionClosed", () => {
            for (let i = 0; i < this._connections.length; i++) {
                if (this._connections[i] === conn) {
                    this._connections.splice(i, 1);
                    break;
                }
            }
        });
        conn.on("entryAssignment", (msg) => {
            if (msg.entryId === 0xFFFF) {
                const entryId = this._nextId;
                this._nextId++;
                msg.entryId = entryId;
                msg.entrySeq = 0;
                this._entries.set(entryId, {
                    name: msg.entryName,
                    id: entryId,
                    type: v3_types_1.V3toNTEntryType.get(msg.entryType),
                    value: msg.entryValue,
                    seq: 0,
                    flags: msg.entryFlags
                });
                this._entryNameToId.set(msg.entryName, entryId);
                // Broadcast
                this._broadcast(null, v3_messages_1.entryAssignmentMessageToBuffer(msg));
                // Emit the entryAdded event
                this.emit("entryAdded", {
                    source: nt_types_1.NTEventUpdateSource.REMOTE,
                    entry: Object.assign({}, this._entries.get(entryId))
                });
            }
        });
        conn.on("entryUpdate", (msg) => {
            if (this._entries.has(msg.entryId)) {
                const entry = this._entries.get(msg.entryId);
                if (msg.entrySeq <= entry.seq) {
                    // the client sequence number is less than ours. reject this
                    return;
                }
                // Update the sequence number
                entry.seq = msg.entrySeq;
                if (entry.type !== v3_types_1.V3toNTEntryType.get(msg.entryType)) {
                    return;
                }
                entry.value = Object.assign({}, msg.entryValue);
                this._broadcast(conn, v3_messages_1.entryUpdateMessageToBuffer({
                    type: v3_types_1.V3MessageType.ENTRY_UPDATE,
                    entryId: entry.id,
                    entrySeq: entry.seq,
                    entryType: v3_types_1.NTtoV3EntryType.get(entry.type),
                    entryValue: entry.value
                }));
                this.emit("entryUpdated", {
                    source: nt_types_1.NTEventUpdateSource.REMOTE,
                    entry: Object.assign({}, entry)
                });
            }
        });
        conn.on("entryFlagsUpdate", (msg) => {
            if (this._entries.has(msg.entryId)) {
                const entry = this._entries.get(msg.entryId);
                entry.flags = Object.assign({}, msg.entryFlags);
                this._broadcast(conn, v3_messages_1.entryFlagsUpdateMessageToBuffer(msg));
                this.emit("entryFlagsUpdated", {
                    source: nt_types_1.NTEventUpdateSource.REMOTE,
                    entry: Object.assign({}, entry)
                });
            }
        });
        conn.on("entryDelete", (msg) => {
            if (this._entries.has(msg.entryId)) {
                const entry = this._entries.get(msg.entryId);
                this._entries.delete(msg.entryId);
                this._entryNameToId.delete(entry.name);
                this._broadcast(conn, v3_messages_1.entryDeleteMessageToBuffer(msg));
                this.emit("entryDeleted", {
                    source: nt_types_1.NTEventUpdateSource.REMOTE,
                    entry: Object.assign({}, entry)
                });
            }
        });
        conn.on("clearAllEntries", () => {
            this._entries.clear();
            this._entryNameToId.clear();
            this._rpcDefinitions.clear();
            this._nextId = 0;
            this._broadcast(conn, v3_messages_1.clearAllEntriesMessageToBuffer());
        });
        conn.on("rpcExecute", (msg) => {
            // TODO Implement
        });
    }
    _broadcast(excludedConn, data) {
        for (let i = 0; i < this._connections.length; i++) {
            const conn = this._connections[i];
            if (conn !== excludedConn) {
                conn.write(data);
            }
        }
    }
    _setEntryData(newEntry) {
        const key = newEntry.name;
        if (this._entryNameToId.has(key)) {
            const currEntryId = this._entryNameToId.get(key);
            const currEntry = this._entries.get(currEntryId);
            if (currEntry.type !== newEntry.type) {
                return false;
            }
            if (protocol_utils_1.ntValueIsEqual(currEntry.value, newEntry.value)) {
                return true;
            }
            newEntry.id = currEntryId;
            newEntry.seq = currEntry.seq + 1;
            newEntry.flags = currEntry.flags;
            this._entries.set(currEntryId, newEntry);
            // Broadcast
            this._broadcast(null, v3_messages_1.entryUpdateMessageToBuffer({
                type: v3_types_1.V3MessageType.ENTRY_UPDATE,
                entryType: v3_types_1.NTtoV3EntryType.get(newEntry.type),
                entryId: newEntry.id,
                entrySeq: newEntry.seq,
                entryValue: newEntry.value
            }));
            this.emit("entryUpdated", {
                source: nt_types_1.NTEventUpdateSource.LOCAL,
                entry: Object.assign({}, newEntry)
            });
        }
        else {
            // This is a new field
            const entryId = this._nextId;
            this._nextId++;
            newEntry.id = entryId;
            newEntry.seq = 0;
            this._entries.set(entryId, newEntry);
            this._entryNameToId.set(newEntry.name, entryId);
            this._broadcast(null, v3_messages_1.entryAssignmentMessageToBuffer({
                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                entryType: v3_types_1.NTtoV3EntryType.get(newEntry.type),
                entryId: newEntry.id,
                entrySeq: newEntry.seq,
                entryName: newEntry.name,
                entryFlags: newEntry.flags ? newEntry.flags : v3_types_1.V3_DEFAULT_FLAGS,
                entryValue: newEntry.value
            }));
            this.emit("entryAdded", {
                source: nt_types_1.NTEventUpdateSource.LOCAL,
                entry: Object.assign({}, newEntry)
            });
        }
        return true;
    }
    _getEntry(key, type) {
        if (this._entryNameToId.has(key)) {
            const currEntryId = this._entryNameToId.get(key);
            const currEntry = this._entries.get(currEntryId);
            // Check types
            if (currEntry.type !== type) {
                throw new nt_types_1.NTEntryTypeMismatchError("Could not convert types");
            }
            return Object.assign({}, currEntry);
        }
        throw new nt_types_1.NTEntryNotFoundError(`Could not find entry with key "${key}"`);
    }
}
exports.default = V3NTServer;
//# sourceMappingURL=v3-nt-server.js.map