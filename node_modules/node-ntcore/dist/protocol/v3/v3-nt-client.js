"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.V3ClientHandshakeManager = void 0;
const nt_client_1 = __importDefault(require("../nt-client"));
const events_1 = require("events");
const v3_types_1 = require("./v3-types");
const v3_messages_1 = require("./v3-messages");
const nt_entry_1 = require("../nt-entry");
const nt_types_1 = require("../nt-types");
const protocol_utils_1 = require("../protocol-utils");
const log_util_1 = __importDefault(require("../../utils/log-util"));
const network_table_instance_1 = require("../../networktables/network-table-instance");
class V3ClientHandshakeManager extends events_1.EventEmitter {
    constructor(clientIdent, writeFunc, logger) {
        super();
        this._state = v3_types_1.V3ClientHandshakeState.V3HS_NOT_CONNECTED;
        this._protocolVersion = { major: 3, minor: 0 };
        this._serverSideEntries = new Map();
        this._clientSideEntries = new Map();
        this._logger = logger;
        this._writeFunc = writeFunc;
        this._ident = clientIdent;
    }
    get protocolVersion() {
        return this._protocolVersion;
    }
    set protocolVersion(val) {
        this._protocolVersion = val;
    }
    beginHandshake(clientEntries, pendingEntries) {
        this._logger.silly("Beginning Handshake");
        // Clear out the maps
        this._serverSideEntries.clear();
        this._clientSideEntries.clear();
        // Copy the client entries
        if (clientEntries) {
            // Make sure that we're making a copy, and not actually referencing
            // the real entries
            clientEntries.forEach(entry => {
                this._clientSideEntries.set(entry.name, Object.assign({}, entry));
            });
        }
        if (pendingEntries) {
            pendingEntries.forEach(entry => {
                this._clientSideEntries.set(entry.name, Object.assign({}, entry));
            });
        }
        this._logger.silly("Preparing to send CLIENT HELLO");
        this._writeFunc(v3_messages_1.clientHelloMessageToBuffer({
            type: v3_types_1.V3MessageType.CLIENT_HELLO,
            clientIdent: this._ident,
            protocolMajor: this._protocolVersion.major,
            protocolMinor: this._protocolVersion.minor
        }))
            .then(() => {
            this._logger.silly("CLIENT HELLO sent");
        });
        const oldState = this._state;
        this._state = v3_types_1.V3ClientHandshakeState.V3HS_AWAIT_SERVER_HELLO;
        this.emit("stateChange", oldState, this._state);
    }
    // Return true if we handled the message, or false if we ignored it
    handleMessage(msg) {
        if (this._state === v3_types_1.V3ClientHandshakeState.V3HS_COMPLETE) {
            return false;
        }
        switch (this._state) {
            case v3_types_1.V3ClientHandshakeState.V3HS_AWAIT_SERVER_HELLO: {
                if (msg.type === v3_types_1.V3MessageType.SERVER_HELLO) {
                    const oldState = this._state;
                    this._state = v3_types_1.V3ClientHandshakeState.V3HS_AWAIT_SERVER_ENTRIES;
                    this.emit("stateChange", oldState, this._state);
                }
                else if (msg.type === v3_types_1.V3MessageType.PROTO_VERSION_UNSUPPORTED) {
                    const protoUnsupportedMsg = msg;
                    this.emit("handshakeError", {
                        major: protoUnsupportedMsg.serverSupportedProtocolMajor,
                        minor: protoUnsupportedMsg.serverSupportedProtocolMinor
                    });
                }
                return true;
            }
            case v3_types_1.V3ClientHandshakeState.V3HS_AWAIT_SERVER_ENTRIES: {
                if (msg.type === v3_types_1.V3MessageType.ENTRY_ASSIGNMENT) {
                    const entryAssignmentMsg = msg;
                    const entry = {
                        name: entryAssignmentMsg.entryName,
                        type: v3_types_1.V3toNTEntryType.get(entryAssignmentMsg.entryType),
                        id: entryAssignmentMsg.entryId,
                        value: entryAssignmentMsg.entryValue,
                        seq: entryAssignmentMsg.entrySeq,
                        flags: entryAssignmentMsg.entryFlags
                    };
                    this._logger.debug("ENTRY ASSIGNMENT: ", entry);
                    this._serverSideEntries.set(entryAssignmentMsg.entryName, entry);
                    // Update the corresponding client-store
                    // Just add/update the value
                    this._clientSideEntries.set(entryAssignmentMsg.entryName, Object.assign({}, entry));
                }
                else if (msg.type === v3_types_1.V3MessageType.SERVER_HELLO_COMPLETE) {
                    this._logger.debug("Received SERVER HELLO COMPLETE");
                    // Then, for every one of the items in our client side
                    // store that is NOT in the serverside store, send an entryAssign
                    const entriesToSend = [];
                    this._clientSideEntries.forEach((entry, name) => {
                        if (!this._serverSideEntries.has(name)) {
                            // Reset the ID and sequence fields
                            entry.id = 0xFFFF;
                            entry.seq = 0;
                            entriesToSend.push(entry);
                        }
                    });
                    if (entriesToSend.length > 0) {
                        this._logger.debug(`${entriesToSend.length} client side entries to send`);
                        entriesToSend.forEach(entry => {
                            this._writeFunc(v3_messages_1.entryAssignmentMessageToBuffer({
                                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                                entryName: entry.name,
                                entryId: entry.id,
                                entrySeq: entry.seq,
                                entryType: v3_types_1.NTtoV3EntryType.get(entry.type),
                                entryValue: entry.value,
                                entryFlags: entry.flags || v3_types_1.V3_DEFAULT_FLAGS
                            }));
                        });
                    }
                    this._writeFunc(v3_messages_1.clientHelloCompleteMessageToBuffer());
                    const oldState = this._state;
                    this._state = v3_types_1.V3ClientHandshakeState.V3HS_COMPLETE;
                    this.emit("stateChange", oldState, this._state);
                    this.emit("handshakeComplete", {
                        clientSideEntries: this._clientSideEntries
                    });
                }
                return true;
            }
        }
    }
}
exports.V3ClientHandshakeManager = V3ClientHandshakeManager;
class V3NTClient extends nt_client_1.default {
    constructor(options) {
        super({ major: 3, minor: 0 }, options);
        this._entryNameToId = new Map();
        this._entries = new Map();
        // RPC Definitions
        this._rpcDefinitions = new Map();
        // Pending entries are those in which the client side has seen, but the
        // server hasn't actually assigned yet
        this._pendingEntries = new Map();
        this._pendingMessages = [];
        this._logger = log_util_1.default.getLogger("NTCORE-CLIENT-V3");
        if (options && options.identifier) {
            this._identifier = options.identifier;
        }
        else {
            this._identifier = `node-ntcore-${Date.now()}`;
        }
        this._handshakeManager = new V3ClientHandshakeManager(this._identifier, (data) => {
            return this._write(data, true);
        }, this._logger);
        this._handshakeManager.protocolVersion = this.version;
    }
    get identifier() {
        return this._identifier;
    }
    // Public API
    setBoolean(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.BOOLEAN,
            name: key,
            value: {
                bool: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getBoolean(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.BOOLEAN).value.bool;
    }
    setDouble(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.DOUBLE,
            name: key,
            value: {
                double: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getDouble(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.DOUBLE).value.double;
    }
    setString(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.STRING,
            name: key,
            value: {
                str: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getString(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.STRING).value.str;
    }
    setBooleanArray(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.BOOLEAN_ARRAY,
            name: key,
            value: {
                bool_array: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getBooleanArray(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.BOOLEAN_ARRAY).value.bool_array;
    }
    setDoubleArray(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.DOUBLE_ARRAY,
            name: key,
            value: {
                double_array: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getDoubleArray(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.DOUBLE_ARRAY).value.double_array;
    }
    setStringArray(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.STRING_ARRAY,
            name: key,
            value: {
                str_array: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getStringArray(key) {
        return this._getEntry(key, nt_entry_1.NTEntryType.STRING_ARRAY).value.str_array;
    }
    setRaw(key, val) {
        const newEntry = {
            type: nt_entry_1.NTEntryType.RAW,
            name: key,
            value: {
                raw: val
            },
            id: 0xFFFF,
            seq: 0,
        };
        return this._setEntryData(newEntry);
    }
    getRaw(key) {
        const entryBuffer = this._getEntry(key, nt_entry_1.NTEntryType.RAW).value.raw;
        const bufCopy = Buffer.allocUnsafe(entryBuffer.length);
        entryBuffer.copy(bufCopy);
        return bufCopy;
    }
    deleteEntry(key) {
        if (this._entryNameToId.has(key)) {
            const entryId = this._entryNameToId.get(key);
            const entry = this._entries.get(entryId);
            this._entries.delete(entryId);
            this._entryNameToId.delete(key);
            this._write(v3_messages_1.entryDeleteMessageToBuffer({
                type: v3_types_1.V3MessageType.ENTRY_DELETE,
                entryId
            }));
            this.emit("entryDeleted", {
                source: nt_types_1.NTEventUpdateSource.LOCAL,
                entry: Object.assign({}, entry)
            });
            return true;
        }
        return false;
    }
    updateEntryFlags(key, flags) {
        if (this._entryNameToId.has(key)) {
            const entryId = this._entryNameToId.get(key);
            const entry = this._entries.get(entryId);
            entry.flags = flags;
            this._write(v3_messages_1.entryFlagsUpdateMessageToBuffer({
                type: v3_types_1.V3MessageType.ENTRY_FLAGS_UPDATE,
                entryId,
                entryFlags: entry.flags
            }));
            this.emit("entryFlagsUpdated", {
                source: nt_types_1.NTEventUpdateSource.LOCAL,
                entry: Object.assign({}, entry)
            });
            return true;
        }
        return false;
    }
    _handshake() {
        return new Promise((resolve, reject) => {
            this._handshakeManager.beginHandshake(this._entries, this._pendingEntries);
            this._handshakeManager.once("handshakeComplete", (data) => {
                this._logger.debug("Handshake Complete");
                // Update our client side with the new entries/updated
                if (data) {
                    // Regenerate the entries
                    // note that ID of 0xFFFF = pending server side
                    this._entryNameToId.clear();
                    this._entries.clear();
                    this._pendingEntries.clear();
                    this._rpcDefinitions.clear();
                    data.clientSideEntries.forEach((entry, name) => {
                        // TODO We should broadcast the events here
                        // Also, we should check to see if we already had
                        // an existing record, which would mean that we've
                        // reconnected to a server
                        if (entry.id !== 0xFFFF) {
                            // Real, server-assigned record
                            let sendUpdateEvent = false;
                            if (this._entryNameToId.has(entry.name)) {
                                // TODO This is something that we already have
                                // send an update event
                                sendUpdateEvent = true;
                            }
                            this._entries.set(entry.id, Object.assign({}, entry));
                            this._entryNameToId.set(entry.name, entry.id);
                            if (entry.type === nt_entry_1.NTEntryType.RPC) {
                                this._rpcDefinitions.set(entry.id, entry.value.rpc);
                            }
                            if (sendUpdateEvent) {
                                this.emit("entryUpdated", {
                                    source: nt_types_1.NTEventUpdateSource.REMOTE,
                                    entry: Object.assign({}, entry)
                                });
                            }
                            else {
                                this.emit("entryAdded", {
                                    source: nt_types_1.NTEventUpdateSource.REMOTE,
                                    entry: Object.assign({}, entry)
                                });
                            }
                        }
                        else {
                            // Pending entry
                            this._pendingEntries.set(entry.name, Object.assign({}, entry));
                            this.emit("entryUpdated", {
                                source: nt_types_1.NTEventUpdateSource.LOCAL,
                                entry: Object.assign({}, entry)
                            });
                        }
                    });
                    this._logger.debug(`Post Handshake: ${this._entries.size} server assigned entries, ${this._pendingEntries.size} pending entries`);
                }
                resolve();
            });
            this._handshakeManager.once("handshakeError", supportedVersion => {
                reject(new nt_types_1.NTProtocolVersionUnsupportedError(supportedVersion, `Server only supports version ${supportedVersion.major}.${supportedVersion.minor}`));
            });
        });
    }
    _handleData(data) {
        if (!this._dataBuffer) {
            this._dataBuffer = Buffer.allocUnsafe(data.length);
            data.copy(this._dataBuffer, 0, 0);
        }
        else {
            this._dataBuffer = Buffer.concat([
                this._dataBuffer,
                data
            ]);
        }
        let nextMessageResult;
        while (nextMessageResult = v3_messages_1.getNextAvailableMessage(this._rpcDefinitions, this._dataBuffer)) {
            this._logger.debug("GOT A MESSAGE: ", v3_types_1.V3MessageTypeToString.get(nextMessageResult.message.type));
            this._pendingMessages.push(nextMessageResult.message);
            this._dataBuffer = Buffer.from(this._dataBuffer.slice(nextMessageResult.newOffset));
        }
        // Now we have pending messages
        if (!this.connected) {
            // Hand off to the handshake manager?
            let lastMessage;
            while (this._pendingMessages.length > 0) {
                lastMessage = this._pendingMessages.shift();
                if (!this._handshakeManager.handleMessage(lastMessage)) {
                    this._pendingMessages.unshift(lastMessage);
                    break;
                }
            }
        }
        else {
            let lastMessage;
            while (this._pendingMessages.length > 0) {
                lastMessage = this._pendingMessages.shift();
                switch (lastMessage.type) {
                    case v3_types_1.V3MessageType.ENTRY_ASSIGNMENT:
                        {
                            this._handleEntryAssignment(lastMessage);
                        }
                        break;
                    case v3_types_1.V3MessageType.ENTRY_UPDATE:
                        {
                            this._handleEntryUpdate(lastMessage);
                        }
                        break;
                    case v3_types_1.V3MessageType.ENTRY_FLAGS_UPDATE:
                        {
                            this._handleEntryFlagsUpdate(lastMessage);
                        }
                        break;
                    case v3_types_1.V3MessageType.ENTRY_DELETE:
                        {
                            this._handleEntryDelete(lastMessage);
                        }
                        break;
                    case v3_types_1.V3MessageType.CLEAR_ALL_ENTRIES:
                        {
                            this._handleClearAllEntries(lastMessage);
                        }
                        break;
                    case v3_types_1.V3MessageType.RPC_RESPONSE:
                        {
                            this._handleRPCRespnse(lastMessage);
                        }
                        break;
                    // NOTE: We don't handle RPC_EXECUTE messages as a client
                    default: {
                        this._logger.debug(`Dropping ${v3_types_1.V3MessageTypeToString.get(lastMessage.type)} message (not handled)`);
                    }
                }
            }
        }
    }
    _handleEntryAssignment(msg) {
        let pendingEntryChanged = false;
        let isPendingEntry = false;
        // Getting an entry assignment from the server
        if (this._entryNameToId.has(msg.entryName)) {
            let entry = this._entries.get(msg.entryId);
            this._logger.info("Client has existing key, deleting: " + msg.entryName +
                " id: " + msg.entryId +
                " NetworkTableType old: " + network_table_instance_1.toNetworkTableType(entry.type) +
                " new: " + network_table_instance_1.toNetworkTableType(v3_types_1.V3toNTEntryType.get(msg.entryType)));
            this.emit("entryDeleted", {
                source: nt_types_1.NTEventUpdateSource.REMOTE,
                entry: Object.assign({}, this._entries.get(msg.entryId))
            });
        }
        else if (this._pendingEntries.has(msg.entryName)) {
            isPendingEntry = true;
            // Promote this pending entry into a real entry
            this._logger.debug(`Promoting ${msg.entryName} from pending to full entry`);
            const pendingEntry = this._pendingEntries.get(msg.entryName);
            if (!protocol_utils_1.ntValueIsEqual(pendingEntry.value, msg.entryValue)) {
                pendingEntryChanged = true;
            }
            this._pendingEntries.delete(msg.entryName);
        }
        this._entries.set(msg.entryId, {
            name: msg.entryName,
            id: msg.entryId,
            type: v3_types_1.V3toNTEntryType.get(msg.entryType),
            value: msg.entryValue,
            seq: msg.entrySeq,
            flags: msg.entryFlags
        });
        this._entryNameToId.set(msg.entryName, msg.entryId);
        this._logger.debug(`Added new entry ${msg.entryName}: `, this._entries.get(msg.entryId));
        if (msg.entryType === v3_types_1.V3EntryType.RPC) {
            this._rpcDefinitions.set(msg.entryId, msg.entryValue);
            this._logger.debug(`Added new RPC Definition ${msg.entryName}: `, msg.entryValue);
        }
        if (!isPendingEntry) {
            // If this wasn't a pending entry, it means it came from the remote
            this.emit("entryAdded", {
                source: nt_types_1.NTEventUpdateSource.REMOTE,
                entry: Object.assign({}, this._entries.get(msg.entryId))
            });
        }
        else if (pendingEntryChanged) {
            // If we did have a pending entry (and it changed)
            this.emit("entryUpdated", {
                source: nt_types_1.NTEventUpdateSource.REMOTE,
                entry: Object.assign({}, this._entries.get(msg.entryId))
            });
        }
    }
    _handleEntryUpdate(msg) {
        if (this._entries.has(msg.entryId)) {
            const entry = this._entries.get(msg.entryId);
            entry.seq = msg.entrySeq;
            entry.value = Object.assign({}, msg.entryValue);
            this._logger.debug(`Updated entry ${entry.name}: `, entry);
            this.emit("entryUpdated", {
                source: nt_types_1.NTEventUpdateSource.REMOTE,
                entry: Object.assign({}, entry)
            });
        }
    }
    _handleEntryFlagsUpdate(msg) {
        if (this._entries.has(msg.entryId)) {
            const entry = this._entries.get(msg.entryId);
            entry.flags = Object.assign({}, msg.entryFlags);
            this._logger.debug(`Updated Entry Flags ${entry.name}: `, entry);
            this.emit("entryFlagsUpdated", {
                source: nt_types_1.NTEventUpdateSource.REMOTE,
                entry: Object.assign({}, entry)
            });
        }
    }
    _handleEntryDelete(msg) {
        if (this._entries.has(msg.entryId)) {
            const entry = this._entries.get(msg.entryId);
            this._entries.delete(entry.id);
            this._entryNameToId.delete(entry.name);
            this._logger.debug(`Deleted Entry: ${entry.name}`);
            this.emit("entryDeleted", {
                source: nt_types_1.NTEventUpdateSource.REMOTE,
                entry: Object.assign({}, entry)
            });
        }
    }
    _handleClearAllEntries(msg) {
        // Unclear if we will ever get this
    }
    _handleRPCRespnse(msg) {
        // TODO Implement
    }
    _setEntryData(newEntry) {
        const key = newEntry.name;
        if (this._entryNameToId.has(key)) {
            const currEntryId = this._entryNameToId.get(key);
            const currEntry = this._entries.get(currEntryId);
            if (currEntry.type !== newEntry.type) {
                return false;
            }
            if (protocol_utils_1.ntValueIsEqual(currEntry.value, newEntry.value)) {
                // Bail out early if the values are the same
                return true;
            }
            newEntry.id = currEntryId;
            newEntry.seq = currEntry.seq + 1;
            newEntry.flags = currEntry.flags;
            // Update the entries map, and send the message
            this._entries.set(currEntryId, newEntry);
            this._write(v3_messages_1.entryUpdateMessageToBuffer({
                type: v3_types_1.V3MessageType.ENTRY_UPDATE,
                entryType: v3_types_1.NTtoV3EntryType.get(newEntry.type),
                entryId: newEntry.id,
                entrySeq: newEntry.seq,
                entryValue: newEntry.value
            }));
            // We should emit a LOCAL entryUpdate message here
            this.emit("entryUpdated", {
                source: nt_types_1.NTEventUpdateSource.LOCAL,
                entry: Object.assign({}, newEntry)
            });
        }
        else if (this._pendingEntries.has(key)) {
            // If a pending message exists with this key, just update the record
            this._pendingEntries.set(key, newEntry);
            // This is a LOCAL change only since it's still pending
            this.emit("entryUpdated", {
                source: nt_types_1.NTEventUpdateSource.LOCAL,
                entry: Object.assign({}, newEntry)
            });
        }
        else {
            // Need to create a new record
            newEntry.seq = 0;
            newEntry.id = 0xFFFF;
            this._pendingEntries.set(key, newEntry);
            this._write(v3_messages_1.entryAssignmentMessageToBuffer({
                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                entryType: v3_types_1.NTtoV3EntryType.get(newEntry.type),
                entryId: 0xFFFF,
                entrySeq: 0,
                entryValue: newEntry.value,
                entryName: newEntry.name,
                entryFlags: newEntry.flags ? newEntry.flags : v3_types_1.V3_DEFAULT_FLAGS
            }));
            this.emit("entryAdded", {
                source: nt_types_1.NTEventUpdateSource.LOCAL,
                entry: Object.assign({}, newEntry)
            });
        }
        return true;
    }
    _getEntry(key, type) {
        if (this._entryNameToId.has(key)) {
            const currEntryId = this._entryNameToId.get(key);
            const currEntry = this._entries.get(currEntryId);
            // Check types
            if (currEntry.type !== type) {
                throw new nt_types_1.NTEntryTypeMismatchError(`Could not convert types`);
            }
            return Object.assign({}, currEntry);
        }
        else if (this._pendingEntries.has(key)) {
            return Object.assign({}, this._pendingEntries.get(key));
        }
        throw new nt_types_1.NTEntryNotFoundError(`Could not find entry with key "${key}"`);
    }
}
exports.default = V3NTClient;
//# sourceMappingURL=v3-nt-client.js.map