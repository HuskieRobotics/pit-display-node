"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeRPCDefinition = exports.decodeRPCDefinition = exports.getNextAvailableMessage = exports.getMessageType = exports.rpcResponseMessageFromBuffer = exports.rpcResponseMessageToBuffer = exports.rpcExecuteMessageFromBuffer = exports.rpcExecuteMessageToBuffer = exports.clearAllEntriesMessageFromBuffer = exports.clearAllEntriesMessageToBuffer = exports.entryDeleteMessageFromBuffer = exports.entryDeleteMessageToBuffer = exports.entryFlagsUpdateMessageFromBuffer = exports.entryFlagsUpdateMessageToBuffer = exports.entryUpdateMessageFromBuffer = exports.entryUpdateMessageToBuffer = exports.entryAssignmentMessageFromBuffer = exports.entryAssignmentMessageToBuffer = exports.entryValueFromBuffer = exports.entryValueToBuffer = exports.clientHelloCompleteMessageFromBuffer = exports.clientHelloCompleteMessageToBuffer = exports.serverHelloMessageFromBuffer = exports.serverHelloMessageToBuffer = exports.serverHelloCompleteMessageFromBuffer = exports.serverHelloCompleteMessageToBuffer = exports.protoVersionUnsupportedMessageFromBuffer = exports.protoVersionUnsupportedMessageToBuffer = exports.clientHelloMessageFromBuffer = exports.clientHelloMessageToBuffer = exports.keepAliveMessageFromBuffer = exports.keepAliveMessageToBuffer = exports.UInt8ToEntryFlags = exports.entryFlagsToUInt8 = void 0;
const ieee754_1 = __importDefault(require("ieee754"));
const protocol_utils_1 = require("../protocol-utils");
const v3_types_1 = require("./v3-types");
// BUFFER MANIPULATION
function checkMessageType(buf, offset, expectedType) {
    if (buf[offset] !== expectedType) {
        throw new protocol_utils_1.InvalidMessageTypeError(`Expected type 0x${expectedType.toString(16)} but got 0x${(buf[offset]).toString(16)} instead`);
    }
}
function checkEntryValue(type, valueObj) {
    if (type === v3_types_1.V3EntryType.BOOLEAN && valueObj.bool === undefined) {
        throw new protocol_utils_1.InvalidEntryValueError("Expected boolean value");
    }
    else if (type === v3_types_1.V3EntryType.DOUBLE && valueObj.double === undefined) {
        throw new protocol_utils_1.InvalidEntryValueError("Expected double value");
    }
    else if (type === v3_types_1.V3EntryType.STRING && valueObj.str === undefined) {
        throw new protocol_utils_1.InvalidEntryValueError("Expected string value");
    }
    else if (type === v3_types_1.V3EntryType.RAW && valueObj.raw === undefined) {
        throw new protocol_utils_1.InvalidEntryValueError("Expected raw value");
    }
    else if (type === v3_types_1.V3EntryType.BOOLEAN_ARRAY && valueObj.bool_array === undefined) {
        throw new protocol_utils_1.InvalidEntryValueError("Expected boolean array value");
    }
    else if (type === v3_types_1.V3EntryType.DOUBLE_ARRAY && valueObj.double_array === undefined) {
        throw new protocol_utils_1.InvalidEntryValueError("Expected double array value");
    }
    else if (type === v3_types_1.V3EntryType.STRING_ARRAY && valueObj.str_array === undefined) {
        throw new protocol_utils_1.InvalidEntryValueError("Expected string array value");
    }
    else if (type === v3_types_1.V3EntryType.RPC && valueObj.rpc === undefined) {
        throw new protocol_utils_1.InvalidEntryValueError("Expected RPC value");
    }
}
function entryFlagsToUInt8(flags) {
    return (typeof flags == "object" && flags !== null && flags.persistent ? 1 : 0);
}
exports.entryFlagsToUInt8 = entryFlagsToUInt8;
function UInt8ToEntryFlags(flagByte) {
    return {
        persistent: (flagByte & 0x1) === 1
    };
}
exports.UInt8ToEntryFlags = UInt8ToEntryFlags;
function keepAliveMessageToBuffer() {
    return Buffer.from([v3_types_1.V3MessageType.KEEP_ALIVE]);
}
exports.keepAliveMessageToBuffer = keepAliveMessageToBuffer;
function keepAliveMessageFromBuffer(buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 1);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.KEEP_ALIVE);
    return {
        message: {
            type: v3_types_1.V3MessageType.KEEP_ALIVE
        },
        newOffset: offset + 1
    };
}
exports.keepAliveMessageFromBuffer = keepAliveMessageFromBuffer;
function clientHelloMessageToBuffer(msg) {
    return Buffer.concat([
        Buffer.from([v3_types_1.V3MessageType.CLIENT_HELLO, 3, 0]),
        protocol_utils_1.encodeLEB128String(msg.clientIdent)
    ]);
}
exports.clientHelloMessageToBuffer = clientHelloMessageToBuffer;
function clientHelloMessageFromBuffer(buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 4); // At least 4 bytes (type, 16-bit revision, string)
    checkMessageType(buf, offset, v3_types_1.V3MessageType.CLIENT_HELLO);
    const protocolMajor = buf.readUInt8(offset + 1);
    const protocolMinor = buf.readUInt8(offset + 2);
    const clientIdent = protocol_utils_1.decodeLEB128String(buf, offset + 3);
    return {
        message: {
            type: v3_types_1.V3MessageType.CLIENT_HELLO,
            protocolMajor,
            protocolMinor,
            clientIdent: clientIdent.value
        },
        newOffset: clientIdent.offset
    };
}
exports.clientHelloMessageFromBuffer = clientHelloMessageFromBuffer;
function protoVersionUnsupportedMessageToBuffer(msg) {
    const version = Buffer.from([
        msg.serverSupportedProtocolMajor,
        msg.serverSupportedProtocolMinor
    ]);
    return Buffer.concat([
        Buffer.from([v3_types_1.V3MessageType.PROTO_VERSION_UNSUPPORTED]),
        version
    ]);
}
exports.protoVersionUnsupportedMessageToBuffer = protoVersionUnsupportedMessageToBuffer;
function protoVersionUnsupportedMessageFromBuffer(buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 3);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.PROTO_VERSION_UNSUPPORTED);
    const serverSupportedProtocolMajor = buf.readUInt8(offset + 1);
    const serverSupportedProtocolMinor = buf.readUInt8(offset + 2);
    return {
        message: {
            type: v3_types_1.V3MessageType.PROTO_VERSION_UNSUPPORTED,
            serverSupportedProtocolMajor,
            serverSupportedProtocolMinor
        },
        newOffset: offset + 3
    };
}
exports.protoVersionUnsupportedMessageFromBuffer = protoVersionUnsupportedMessageFromBuffer;
function serverHelloCompleteMessageToBuffer() {
    return Buffer.from([v3_types_1.V3MessageType.SERVER_HELLO_COMPLETE]);
}
exports.serverHelloCompleteMessageToBuffer = serverHelloCompleteMessageToBuffer;
function serverHelloCompleteMessageFromBuffer(buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 1);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.SERVER_HELLO_COMPLETE);
    return {
        message: {
            type: v3_types_1.V3MessageType.SERVER_HELLO_COMPLETE
        },
        newOffset: offset + 1
    };
}
exports.serverHelloCompleteMessageFromBuffer = serverHelloCompleteMessageFromBuffer;
function serverHelloMessageToBuffer(msg) {
    return Buffer.concat([
        Buffer.from([v3_types_1.V3MessageType.SERVER_HELLO, msg.clientPreviouslySeen ? 1 : 0]),
        protocol_utils_1.encodeLEB128String(msg.serverIdentity)
    ]);
}
exports.serverHelloMessageToBuffer = serverHelloMessageToBuffer;
function serverHelloMessageFromBuffer(buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 3);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.SERVER_HELLO);
    const flags = buf[offset + 1];
    const serverIdentity = protocol_utils_1.decodeLEB128String(buf, offset + 2);
    return {
        message: {
            type: v3_types_1.V3MessageType.SERVER_HELLO,
            clientPreviouslySeen: (flags & 0x1) === 1,
            serverIdentity: serverIdentity.value
        },
        newOffset: serverIdentity.offset
    };
}
exports.serverHelloMessageFromBuffer = serverHelloMessageFromBuffer;
function clientHelloCompleteMessageToBuffer() {
    return Buffer.from([v3_types_1.V3MessageType.CLIENT_HELLO_COMPLETE]);
}
exports.clientHelloCompleteMessageToBuffer = clientHelloCompleteMessageToBuffer;
function clientHelloCompleteMessageFromBuffer(buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 1);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.CLIENT_HELLO_COMPLETE);
    return {
        message: {
            type: v3_types_1.V3MessageType.CLIENT_HELLO_COMPLETE
        },
        newOffset: offset + 1
    };
}
exports.clientHelloCompleteMessageFromBuffer = clientHelloCompleteMessageFromBuffer;
function entryValueToBuffer(type, valueObj) {
    checkEntryValue(type, valueObj);
    switch (type) {
        case v3_types_1.V3EntryType.BOOLEAN: {
            return Buffer.from([valueObj.bool ? 1 : 0]);
        }
        case v3_types_1.V3EntryType.DOUBLE: {
            const doubleBuf = Buffer.alloc(8);
            ieee754_1.default.write(doubleBuf, valueObj.double, 0, false, 52, 8);
            return doubleBuf;
        }
        case v3_types_1.V3EntryType.STRING: {
            return protocol_utils_1.encodeLEB128String(valueObj.str);
        }
        case v3_types_1.V3EntryType.RAW: {
            return Buffer.concat([
                protocol_utils_1.toUnsignedLEB128(valueObj.raw.length),
                valueObj.raw
            ]);
        }
        case v3_types_1.V3EntryType.BOOLEAN_ARRAY: {
            return Buffer.concat([
                Buffer.from([valueObj.bool_array.length]),
                Buffer.from(valueObj.bool_array.map(val => {
                    return val ? 1 : 0;
                }))
            ]);
        }
        case v3_types_1.V3EntryType.DOUBLE_ARRAY: {
            return Buffer.concat([
                Buffer.from([valueObj.double_array.length]),
                Buffer.concat(valueObj.double_array.map(value => {
                    const buf = Buffer.alloc(8);
                    ieee754_1.default.write(buf, value, 0, false, 52, 8);
                    return buf;
                }))
            ]);
        }
        case v3_types_1.V3EntryType.STRING_ARRAY: {
            return Buffer.concat([
                Buffer.from([valueObj.str_array.length]),
                Buffer.concat(valueObj.str_array.map(value => {
                    return protocol_utils_1.encodeLEB128String(value);
                }))
            ]);
        }
        case v3_types_1.V3EntryType.RPC: {
            const encodedRpcBuf = encodeRPCDefinition(valueObj.rpc);
            return Buffer.concat([
                Buffer.from([encodedRpcBuf.length]),
                encodedRpcBuf
            ]);
        }
    }
}
exports.entryValueToBuffer = entryValueToBuffer;
function entryValueFromBuffer(type, buf, offset = 0) {
    switch (type) {
        case v3_types_1.V3EntryType.BOOLEAN: {
            protocol_utils_1.checkBufferLength(buf, offset, 1);
            return {
                value: {
                    bool: buf[offset] === 1
                },
                newOffset: offset + 1
            };
        }
        case v3_types_1.V3EntryType.DOUBLE: {
            protocol_utils_1.checkBufferLength(buf, offset, 8);
            return {
                value: {
                    double: ieee754_1.default.read(buf, offset, false, 52, 8)
                },
                newOffset: offset + 8
            };
        }
        case v3_types_1.V3EntryType.STRING: {
            const strResult = protocol_utils_1.decodeLEB128String(buf, offset);
            return {
                value: {
                    str: strResult.value
                },
                newOffset: strResult.offset
            };
        }
        case v3_types_1.V3EntryType.RAW: {
            const dataLenResult = protocol_utils_1.fromUnsignedLEB128(buf, offset);
            const dataLen = dataLenResult.value;
            protocol_utils_1.checkBufferLength(buf, dataLenResult.offset, dataLen);
            const rawBuf = Buffer.allocUnsafe(dataLen);
            buf.copy(rawBuf, 0, dataLenResult.offset, dataLenResult.offset + dataLen);
            return {
                value: {
                    raw: rawBuf
                },
                newOffset: dataLenResult.offset + dataLen
            };
        }
        case v3_types_1.V3EntryType.BOOLEAN_ARRAY: {
            const numElems = buf.readUInt8(offset);
            let bufOffset = offset + 1;
            protocol_utils_1.checkBufferLength(buf, bufOffset, numElems);
            const boolArray = [];
            for (let i = 0; i < numElems; i++) {
                boolArray.push(buf[bufOffset] === 1);
                bufOffset++;
            }
            return {
                value: {
                    bool_array: boolArray
                },
                newOffset: bufOffset
            };
        }
        case v3_types_1.V3EntryType.DOUBLE_ARRAY: {
            const numElems = buf.readUInt8(offset);
            let bufOffset = offset + 1;
            protocol_utils_1.checkBufferLength(buf, bufOffset, numElems * 8);
            const doubleArray = [];
            for (let i = 0; i < numElems; i++) {
                doubleArray.push(ieee754_1.default.read(buf, bufOffset, false, 52, 8));
                bufOffset += 8;
            }
            return {
                value: {
                    double_array: doubleArray
                },
                newOffset: bufOffset
            };
        }
        case v3_types_1.V3EntryType.STRING_ARRAY: {
            const numElems = buf.readUInt8(offset);
            let bufOffset = offset + 1;
            protocol_utils_1.checkBufferLength(buf, bufOffset, numElems);
            const strArray = [];
            for (let i = 0; i < numElems; i++) {
                const strResult = protocol_utils_1.decodeLEB128String(buf, bufOffset);
                strArray.push(strResult.value);
                bufOffset = strResult.offset;
            }
            return {
                value: {
                    str_array: strArray
                },
                newOffset: bufOffset
            };
        }
        case v3_types_1.V3EntryType.RPC: {
            const bufLenResult = protocol_utils_1.fromUnsignedLEB128(buf, offset);
            const bufLen = bufLenResult.value;
            protocol_utils_1.checkBufferLength(buf, bufLenResult.offset, bufLen);
            // The buffer starting at bufLenResult.offset now holds the RPC
            // definition entry
            const rpcDefinitionResult = decodeRPCDefinition(buf, bufLenResult.offset);
            return {
                value: {
                    rpc: rpcDefinitionResult.value
                },
                newOffset: rpcDefinitionResult.newOffset
            };
        }
    }
}
exports.entryValueFromBuffer = entryValueFromBuffer;
function entryAssignmentMessageToBuffer(msg) {
    checkEntryValue(msg.entryType, msg.entryValue);
    const nameBuf = protocol_utils_1.encodeLEB128String(msg.entryName);
    const idBuf = Buffer.alloc(2);
    idBuf.writeUInt16BE(msg.entryId);
    const seqBuf = Buffer.alloc(2);
    seqBuf.writeUInt16BE(msg.entrySeq);
    return Buffer.concat([
        Buffer.from([v3_types_1.V3MessageType.ENTRY_ASSIGNMENT]),
        nameBuf,
        Buffer.from([msg.entryType]),
        idBuf,
        seqBuf,
        Buffer.from([entryFlagsToUInt8(msg.entryFlags)]),
        entryValueToBuffer(msg.entryType, msg.entryValue)
    ]);
}
exports.entryAssignmentMessageToBuffer = entryAssignmentMessageToBuffer;
function entryAssignmentMessageFromBuffer(buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 9);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.ENTRY_ASSIGNMENT);
    let bufOffset = offset + 1;
    // Extract the string
    const entryNameResult = protocol_utils_1.decodeLEB128String(buf, bufOffset);
    const entryName = entryNameResult.value;
    // The offset now points to the byte AFTER the end of the string
    bufOffset = entryNameResult.offset;
    if (!(buf[bufOffset] in v3_types_1.ByteToV3EntryType)) {
        throw new protocol_utils_1.InvalidEntryTypeError("Invalid Type Found");
    }
    const entryType = buf[bufOffset];
    bufOffset += 1; // This will now point to the ID
    const entryId = buf.readUInt16BE(bufOffset);
    bufOffset += 2; // This will now point to the Sequence
    const entrySeq = buf.readUInt16BE(bufOffset);
    bufOffset += 2; // This will now point to the Flags
    const entryFlags = UInt8ToEntryFlags(buf[bufOffset]);
    bufOffset += 1; // This will now point at the EntryValue
    const entryValueResult = entryValueFromBuffer(entryType, buf, bufOffset);
    return {
        message: {
            type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
            entryName,
            entryType,
            entryId,
            entrySeq,
            entryFlags,
            entryValue: entryValueResult.value
        },
        newOffset: entryValueResult.newOffset
    };
}
exports.entryAssignmentMessageFromBuffer = entryAssignmentMessageFromBuffer;
function entryUpdateMessageToBuffer(msg) {
    checkEntryValue(msg.entryType, msg.entryValue);
    const idBuf = Buffer.alloc(2);
    idBuf.writeUInt16BE(msg.entryId);
    const seqBuf = Buffer.alloc(2);
    seqBuf.writeUInt16BE(msg.entrySeq);
    return Buffer.concat([
        Buffer.from([v3_types_1.V3MessageType.ENTRY_UPDATE]),
        idBuf,
        seqBuf,
        Buffer.from([msg.entryType]),
        entryValueToBuffer(msg.entryType, msg.entryValue)
    ]);
}
exports.entryUpdateMessageToBuffer = entryUpdateMessageToBuffer;
function entryUpdateMessageFromBuffer(buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 7);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.ENTRY_UPDATE);
    let bufOffset = offset + 1;
    const entryId = buf.readUInt16BE(bufOffset);
    bufOffset += 2; // Now pointing to seq
    const entrySeq = buf.readUInt16BE(bufOffset);
    bufOffset += 2; // Now pointing to type
    if (!(buf[bufOffset] in v3_types_1.ByteToV3EntryType)) {
        throw new protocol_utils_1.InvalidEntryTypeError("Invalid Type Found");
    }
    const entryType = buf[bufOffset];
    bufOffset += 1; // Now pointing to value
    const entryValueResult = entryValueFromBuffer(entryType, buf, bufOffset);
    return {
        message: {
            type: v3_types_1.V3MessageType.ENTRY_UPDATE,
            entryId,
            entrySeq,
            entryType,
            entryValue: entryValueResult.value
        },
        newOffset: entryValueResult.newOffset
    };
}
exports.entryUpdateMessageFromBuffer = entryUpdateMessageFromBuffer;
function entryFlagsUpdateMessageToBuffer(msg) {
    const idBuf = Buffer.alloc(2);
    idBuf.writeUInt16BE(msg.entryId);
    return Buffer.concat([
        Buffer.from([v3_types_1.V3MessageType.ENTRY_FLAGS_UPDATE]),
        idBuf,
        Buffer.from([entryFlagsToUInt8(msg.entryFlags)])
    ]);
}
exports.entryFlagsUpdateMessageToBuffer = entryFlagsUpdateMessageToBuffer;
function entryFlagsUpdateMessageFromBuffer(buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 4);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.ENTRY_FLAGS_UPDATE);
    const entryId = buf.readUInt16BE(offset + 1);
    const entryFlags = UInt8ToEntryFlags(buf[offset + 3]);
    return {
        message: {
            type: v3_types_1.V3MessageType.ENTRY_FLAGS_UPDATE,
            entryId,
            entryFlags
        },
        newOffset: offset + 4
    };
}
exports.entryFlagsUpdateMessageFromBuffer = entryFlagsUpdateMessageFromBuffer;
function entryDeleteMessageToBuffer(msg) {
    const buf = Buffer.alloc(3);
    buf[0] = v3_types_1.V3MessageType.ENTRY_DELETE;
    buf.writeUInt16BE(msg.entryId, 1);
    return buf;
}
exports.entryDeleteMessageToBuffer = entryDeleteMessageToBuffer;
function entryDeleteMessageFromBuffer(buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 3);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.ENTRY_DELETE);
    return {
        message: {
            type: v3_types_1.V3MessageType.ENTRY_DELETE,
            entryId: buf.readUInt16BE(1)
        },
        newOffset: offset + 3
    };
}
exports.entryDeleteMessageFromBuffer = entryDeleteMessageFromBuffer;
function clearAllEntriesMessageToBuffer() {
    const buf = Buffer.alloc(5);
    buf[0] = v3_types_1.V3MessageType.CLEAR_ALL_ENTRIES;
    buf.writeUInt32BE(v3_types_1.CLEAR_ALL_ENTRIES_MAGIC_VALUE, 1);
    return buf;
}
exports.clearAllEntriesMessageToBuffer = clearAllEntriesMessageToBuffer;
function clearAllEntriesMessageFromBuffer(buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 5);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.CLEAR_ALL_ENTRIES);
    if (buf.readUInt32BE(1) !== v3_types_1.CLEAR_ALL_ENTRIES_MAGIC_VALUE) {
        throw new protocol_utils_1.InvalidEntryValueError("Invalid Magic number for CLEAR ALL ENTRIES");
    }
    return {
        message: {
            type: v3_types_1.V3MessageType.CLEAR_ALL_ENTRIES
        },
        newOffset: offset + 5
    };
}
exports.clearAllEntriesMessageFromBuffer = clearAllEntriesMessageFromBuffer;
function rpcExecuteMessageToBuffer(msg) {
    const headerBuf = Buffer.alloc(3);
    headerBuf[0] = v3_types_1.V3MessageType.RPC_EXECUTE;
    headerBuf.writeUInt16BE(msg.rpcDefinitionId, 1);
    const idBuf = Buffer.alloc(2);
    idBuf.writeUInt16BE(msg.uniqueId);
    const numParamsBuf = protocol_utils_1.toUnsignedLEB128(msg.parameters.length);
    const paramBufs = msg.parameters.map(param => {
        return entryValueToBuffer(param.type, param.value);
    });
    return Buffer.concat([
        headerBuf,
        idBuf,
        numParamsBuf,
        Buffer.concat(paramBufs)
    ]);
}
exports.rpcExecuteMessageToBuffer = rpcExecuteMessageToBuffer;
function rpcExecuteMessageFromBuffer(rpcDefinitions, buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 6);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.RPC_EXECUTE);
    let bufOffset = offset + 1; // Points to Definition Entry ID
    const rpcDefinitionId = buf.readUInt16BE(bufOffset);
    if (!rpcDefinitions.has(rpcDefinitionId)) {
        throw new Error("No RPC definition found");
    }
    const rpcDefinition = rpcDefinitions.get(rpcDefinitionId);
    bufOffset += 2; // Points to unique ID
    const uniqueId = buf.readUInt16BE(bufOffset);
    bufOffset += 2; // Points to param value length
    const numParamResults = protocol_utils_1.fromUnsignedLEB128(buf, bufOffset);
    const numParams = numParamResults.value;
    if (numParams !== rpcDefinition.parameters.length) {
        throw new Error("Mismatch in RPC parameter counts");
    }
    const parameters = [];
    bufOffset = numParamResults.offset; // Now points to the first param value
    for (let i = 0; i < numParams; i++) {
        const paramDef = rpcDefinition.parameters[i];
        const valueResult = entryValueFromBuffer(paramDef.type, buf, bufOffset);
        parameters.push({
            type: paramDef.type,
            name: paramDef.name.slice(),
            value: valueResult.value
        });
        bufOffset = valueResult.newOffset;
    }
    return {
        message: {
            type: v3_types_1.V3MessageType.RPC_EXECUTE,
            rpcDefinitionId,
            uniqueId,
            parameters
        },
        newOffset: bufOffset
    };
}
exports.rpcExecuteMessageFromBuffer = rpcExecuteMessageFromBuffer;
function rpcResponseMessageToBuffer(msg) {
    const headerBuf = Buffer.alloc(3);
    headerBuf[0] = v3_types_1.V3MessageType.RPC_RESPONSE;
    headerBuf.writeUInt16BE(msg.rpcDefinitionId, 1);
    const idBuf = Buffer.alloc(2);
    idBuf.writeUInt16BE(msg.uniqueId);
    const numResultsBuf = protocol_utils_1.toUnsignedLEB128(msg.results.length);
    const resultBufs = msg.results.map(result => {
        return entryValueToBuffer(result.type, result.value);
    });
    return Buffer.concat([
        headerBuf,
        idBuf,
        numResultsBuf,
        Buffer.concat(resultBufs)
    ]);
}
exports.rpcResponseMessageToBuffer = rpcResponseMessageToBuffer;
function rpcResponseMessageFromBuffer(rpcDefinitions, buf, offset = 0) {
    protocol_utils_1.checkBufferLength(buf, offset, 6);
    checkMessageType(buf, offset, v3_types_1.V3MessageType.RPC_RESPONSE);
    let bufOffset = offset + 1; // Points to Definiteion Entry ID
    const rpcDefinitionId = buf.readUInt16BE(bufOffset);
    if (!rpcDefinitions.has(rpcDefinitionId)) {
        throw new Error("No RPC definition found");
    }
    const rpcDef = rpcDefinitions.get(rpcDefinitionId);
    bufOffset += 2; // Points to unique ID
    const uniqueId = buf.readUInt16BE(bufOffset);
    bufOffset += 2; // Points to result length value
    const numResultsResult = protocol_utils_1.fromUnsignedLEB128(buf, bufOffset);
    const numResults = numResultsResult.value;
    if (numResults !== rpcDef.results.length) {
        throw new Error("Mismatch in RPC result counts");
    }
    const results = [];
    bufOffset = numResultsResult.offset;
    for (let i = 0; i < numResults; i++) {
        const resultDef = rpcDef.results[i];
        const valueResult = entryValueFromBuffer(resultDef.type, buf, bufOffset);
        results.push({
            type: resultDef.type,
            name: resultDef.name.slice(),
            value: valueResult.value
        });
        bufOffset = valueResult.newOffset;
    }
    return {
        message: {
            type: v3_types_1.V3MessageType.RPC_RESPONSE,
            rpcDefinitionId,
            uniqueId,
            results
        },
        newOffset: bufOffset
    };
}
exports.rpcResponseMessageFromBuffer = rpcResponseMessageFromBuffer;
// Utility functions
function getMessageType(buf, offset = 0) {
    if (!(buf[offset] in v3_types_1.ByteToV3MessageType)) {
        throw new protocol_utils_1.InvalidMessageTypeError(`Invalid message type found at offset ${offset}`);
    }
    return buf[offset];
}
exports.getMessageType = getMessageType;
function getNextAvailableMessage(rpcDefinitions, buf, offset = 0) {
    let msgType;
    try {
        msgType = getMessageType(buf, offset);
    }
    catch (e) {
        // console.log("ERR while getting message type: ", e);
        return undefined;
    }
    try {
        switch (msgType) {
            case v3_types_1.V3MessageType.KEEP_ALIVE: {
                return {
                    message: {
                        type: msgType
                    },
                    newOffset: offset + 1
                };
            }
            case v3_types_1.V3MessageType.CLIENT_HELLO: {
                const result = clientHelloMessageFromBuffer(buf, offset);
                return {
                    message: result.message,
                    newOffset: result.newOffset
                };
            }
            case v3_types_1.V3MessageType.PROTO_VERSION_UNSUPPORTED: {
                const result = protoVersionUnsupportedMessageFromBuffer(buf, offset);
                return {
                    message: result.message,
                    newOffset: result.newOffset
                };
            }
            case v3_types_1.V3MessageType.SERVER_HELLO_COMPLETE: {
                return {
                    message: {
                        type: msgType
                    },
                    newOffset: offset + 1
                };
            }
            case v3_types_1.V3MessageType.SERVER_HELLO: {
                const result = serverHelloMessageFromBuffer(buf, offset);
                return {
                    message: result.message,
                    newOffset: result.newOffset
                };
            }
            case v3_types_1.V3MessageType.CLIENT_HELLO_COMPLETE: {
                const result = clientHelloCompleteMessageFromBuffer(buf, offset);
                return Object.assign({}, result);
            }
            case v3_types_1.V3MessageType.ENTRY_UPDATE: {
                const result = entryUpdateMessageFromBuffer(buf, offset);
                return Object.assign({}, result);
            }
            case v3_types_1.V3MessageType.ENTRY_ASSIGNMENT: {
                const result = entryAssignmentMessageFromBuffer(buf, offset);
                return Object.assign({}, result);
            }
            case v3_types_1.V3MessageType.ENTRY_FLAGS_UPDATE: {
                const result = entryFlagsUpdateMessageFromBuffer(buf, offset);
                return Object.assign({}, result);
            }
            case v3_types_1.V3MessageType.ENTRY_DELETE: {
                const result = entryDeleteMessageFromBuffer(buf, offset);
                return Object.assign({}, result);
            }
            case v3_types_1.V3MessageType.CLEAR_ALL_ENTRIES: {
                const result = clearAllEntriesMessageFromBuffer(buf, offset);
                return Object.assign({}, result);
            }
            case v3_types_1.V3MessageType.RPC_EXECUTE: {
                const result = rpcExecuteMessageFromBuffer(rpcDefinitions, buf, offset);
                return Object.assign({}, result);
            }
            case v3_types_1.V3MessageType.RPC_RESPONSE: {
                const result = rpcResponseMessageFromBuffer(rpcDefinitions, buf, offset);
                return Object.assign({}, result);
            }
        }
    }
    catch (e) {
        return undefined;
    }
}
exports.getNextAvailableMessage = getNextAvailableMessage;
function decodeRPCDefinition(buf, offset = 0) {
    let bufOffset = offset;
    if (buf[bufOffset] !== 1) {
        throw new Error("Unsupported RPC Version");
    }
    bufOffset += 1; // This now points to the Name string
    const procedureNameResult = protocol_utils_1.decodeLEB128String(buf, bufOffset);
    const procedureName = procedureNameResult.value;
    bufOffset = procedureNameResult.offset; // This now points to the number of params
    const numParams = buf[bufOffset];
    bufOffset += 1; // This now points to the first parameter spec definition
    const params = [];
    for (let i = 0; i < numParams; i++) {
        const decodedParam = decodeRPCParameterSpec(buf, bufOffset);
        params.push(decodedParam.value);
        bufOffset = decodedParam.newOffset;
    }
    const numResults = buf[bufOffset];
    bufOffset += 1;
    const results = [];
    for (let i = 0; i < numResults; i++) {
        const decodedResult = decodeRPCResultSpec(buf, bufOffset);
        results.push(decodedResult.value);
        bufOffset = decodedResult.newOffset;
    }
    // bufOffset will now point to the next byte after the RPC def
    return {
        value: {
            name: procedureName,
            parameters: params,
            results
        },
        newOffset: bufOffset
    };
}
exports.decodeRPCDefinition = decodeRPCDefinition;
function encodeRPCDefinition(rpcDef) {
    const paramBuffers = rpcDef.parameters.map(param => {
        return encodeRPCParameterSpec(param);
    });
    const resultBuffers = rpcDef.results.map(result => {
        return encodeRPCResultSpec(result);
    });
    return Buffer.concat([
        Buffer.from([1]),
        protocol_utils_1.encodeLEB128String(rpcDef.name),
        Buffer.from([paramBuffers.length]),
        Buffer.concat(paramBuffers),
        Buffer.from([resultBuffers.length]),
        Buffer.concat(resultBuffers)
    ]);
}
exports.encodeRPCDefinition = encodeRPCDefinition;
function decodeRPCParameterSpec(buf, offset = 0) {
    let bufOffset = offset;
    const type = buf[bufOffset];
    bufOffset += 1; // This now points at the param name
    const paramNameResult = protocol_utils_1.decodeLEB128String(buf, bufOffset);
    const paramName = paramNameResult.value;
    bufOffset = paramNameResult.offset; // This now points at the default value
    const defaultValueResult = entryValueFromBuffer(type, buf, bufOffset);
    return {
        value: {
            type,
            name: paramName,
            value: defaultValueResult.value
        },
        newOffset: defaultValueResult.newOffset
    };
}
function encodeRPCParameterSpec(param) {
    return Buffer.concat([
        Buffer.from([param.type]),
        protocol_utils_1.encodeLEB128String(param.name),
        entryValueToBuffer(param.type, param.value)
    ]);
}
function decodeRPCResultSpec(buf, offset = 0) {
    let bufOffset = offset;
    const type = buf[bufOffset];
    bufOffset += 1; // This now points at the result name
    const resultNameResult = protocol_utils_1.decodeLEB128String(buf, bufOffset);
    return {
        value: {
            type,
            name: resultNameResult.value,
            value: {}
        },
        newOffset: resultNameResult.offset
    };
}
function encodeRPCResultSpec(result) {
    return Buffer.concat([
        Buffer.from([result.type]),
        protocol_utils_1.encodeLEB128String(result.name)
    ]);
}
//# sourceMappingURL=v3-messages.js.map