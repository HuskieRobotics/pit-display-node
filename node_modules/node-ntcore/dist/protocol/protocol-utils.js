"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ntValueIsEqual = exports.decodeLEB128String = exports.encodeLEB128String = exports.checkBufferLength = exports.InvalidEntryTypeError = exports.InvalidEntryValueError = exports.InvalidMessageTypeError = exports.BufferLengthError = exports.fromUnsignedLEB128 = exports.toUnsignedLEB128 = exports.parseNetworkEndpointInfo = void 0;
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
function parseNetworkEndpointInfo(address, port) {
    // Prepend the protocol if there isn't one
    if (!(/:\/\/\w/).test(address)) {
        address = "tcp://" + address;
    }
    const parsedURL = new URL(address);
    const parsedHostname = parsedURL.hostname;
    let parsedPort = parseInt(parsedURL.port, 10);
    if (isNaN(parsedPort)) {
        parsedPort = port;
    }
    return {
        address: parsedHostname,
        port: parsedPort
    };
}
exports.parseNetworkEndpointInfo = parseNetworkEndpointInfo;
function toUnsignedLEB128(num) {
    let n = num;
    let result = [];
    while (true) {
        const byte = n & 0x7F;
        n >>= 7;
        if ((n === 0 && (byte & 0x40) === 0) || (n === -1 && (byte & 0x40) !== 0)) {
            result.push(byte);
            break;
        }
        else {
            result.push(byte | 0x80);
        }
    }
    return Buffer.from(result);
}
exports.toUnsignedLEB128 = toUnsignedLEB128;
function fromUnsignedLEB128(buf, offset) {
    let result = 0;
    let shift = 0;
    while (true) {
        const byte = buf[offset];
        offset++;
        result |= (byte & 0x7F) << shift;
        shift += 7;
        if ((byte & 0x80) === 0) {
            if (shift < 32 && (byte & 0x40) !== 0) {
                result |= (~0 << shift);
                break;
            }
            break;
        }
    }
    return {
        value: result,
        offset
    };
}
exports.fromUnsignedLEB128 = fromUnsignedLEB128;
class BufferLengthError extends Error {
}
exports.BufferLengthError = BufferLengthError;
class InvalidMessageTypeError extends Error {
}
exports.InvalidMessageTypeError = InvalidMessageTypeError;
class InvalidEntryValueError extends Error {
}
exports.InvalidEntryValueError = InvalidEntryValueError;
class InvalidEntryTypeError extends Error {
}
exports.InvalidEntryTypeError = InvalidEntryTypeError;
function checkBufferLength(buf, offset, bytesToRead = 1) {
    if (offset + bytesToRead > buf.length) {
        throw new BufferLengthError(`Cannot read ${bytesToRead} byte(s) starting at ${offset}. Buffer length: ${buf.length}`);
    }
}
exports.checkBufferLength = checkBufferLength;
function encodeLEB128String(msg) {
    return Buffer.concat([
        toUnsignedLEB128(msg.length),
        Buffer.from(msg, "utf-8")
    ]);
}
exports.encodeLEB128String = encodeLEB128String;
function decodeLEB128String(buf, offset = 0) {
    let decodeResult = fromUnsignedLEB128(buf, offset);
    const end = decodeResult.offset + decodeResult.value;
    checkBufferLength(buf, decodeResult.offset, decodeResult.value);
    return {
        offset: end,
        value: buf.slice(decodeResult.offset, end).toString("utf-8")
    };
}
exports.decodeLEB128String = decodeLEB128String;
function ntValueIsEqual(a, b) {
    return fast_deep_equal_1.default(a, b);
}
exports.ntValueIsEqual = ntValueIsEqual;
//# sourceMappingURL=protocol-utils.js.map