"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const network_table_instance_1 = require("./network-table-instance");
const NT_PATH_SEPARATOR = "/";
const normalizeRegex = new RegExp(`${NT_PATH_SEPARATOR}{2,}`, "g");
class NetworkTable {
    constructor(instance, path) {
        this._entries = new Map();
        this._instance = instance;
        this._path = NetworkTable.normalizeKey(path);
        this._pathWithSep = path + NT_PATH_SEPARATOR;
    }
    // STATIC METHODS AND PROPERTIES
    /**
     * Gets the base name of a key. e.g. "/foo/bar" becomes "bar".
     * If the key has a trailing slash, returns an empty string
     * @param key
     */
    static basenameKey(key) {
        const lastSepIdx = key.lastIndexOf(NT_PATH_SEPARATOR);
        if (lastSepIdx === -1) {
            return key;
        }
        return key.substring(lastSepIdx + 1);
    }
    /**
     * Normalizes a key by removing consecutive slashes and optionally starting
     * with a leading slash. E.g.
     *
     * normalizeKey("/foo/bar", true) => "/foo/bar"
     * normalizeKey("foo/bar", true) => "/foo/bar"
     * normalizeKey("/foo/bar", false) => "foo/bar"
     * normalizeKey("foo//bar", false) => "foo/bar"
     * @param key
     * @param withLeadingSlash whether or not the normalized key should begin with a leading slash
     */
    static normalizeKey(key, withLeadingSlash = true) {
        let normalized = "";
        if (withLeadingSlash) {
            normalized = NT_PATH_SEPARATOR + key;
        }
        else {
            normalized = key;
        }
        normalized = normalized.replace(normalizeRegex, NT_PATH_SEPARATOR);
        if (!withLeadingSlash && normalized.charAt(0) === NT_PATH_SEPARATOR) {
            normalized = normalized.substring(1);
        }
        return normalized;
    }
    /**
     * Gets a list of all the super tables of a given key.
     * E.g. the key "/foo/bar/baz" has hierarchy of "/", "/foo", "/foo/bar", "/foo/bar/baz"
     * @param key
     */
    static getHierarchy(key) {
        const normalized = this.normalizeKey(key, true);
        const result = [];
        if (normalized.length === 1) {
            result.push(normalized);
            return result;
        }
        for (let i = 1;; i = normalized.indexOf(NT_PATH_SEPARATOR, i + 1)) {
            if (i === -1) {
                result.push(normalized);
                break;
            }
            else {
                result.push(normalized.substring(0, i));
            }
        }
        return result;
    }
    toString() {
        return `NetworkTable: ${this._path}`;
    }
    /**
     * Get the entry for a sub key
     * @param key
     */
    getEntry(key) {
        let entry = this._entries.get(key);
        if (!entry) {
            entry = this._instance.getEntry(this._pathWithSep + key);
            this._entries.set(key, entry);
        }
        return entry;
    }
    addEntryListener(key, listener, listenerFlags) {
        if (key !== null) {
            const entry = this.getEntry(key);
            return this._instance.addEntryListener(entry, (key, entry, value, flags) => {
                listener(this, key, entry, value, flags);
            }, listenerFlags);
        }
        const prefixLen = this._path.length + 1;
        return this._instance.addEntryListener(this._path, (key, entry, value, flags) => {
            const relativeKey = key.substring(prefixLen);
            if (relativeKey.indexOf(NT_PATH_SEPARATOR) !== -1) {
                // Part of a sub table, ignore
                return;
            }
            listener(this, relativeKey, entry, value, flags);
        }, listenerFlags);
    }
    removeEntryListener(guid) {
        this._instance.removeEntryListener(guid);
    }
    addSubTableListener(listener, localNotify) {
        let flags = network_table_instance_1.EntryListenerFlags.NEW | network_table_instance_1.EntryListenerFlags.IMMEDIATE;
        if (localNotify) {
            flags |= network_table_instance_1.EntryListenerFlags.LOCAL;
        }
        const prefixLen = this._path.length + 1;
        const parent = this;
        const notifiedTables = new Set();
        return this._instance.addEntryListener(this._pathWithSep, (key, entry, value, flags) => {
            const relativeKey = key.substring(prefixLen);
            const endSubTable = relativeKey.indexOf(NT_PATH_SEPARATOR);
            if (endSubTable === -1) {
                return;
            }
            const subTableKey = relativeKey.substring(0, endSubTable);
            if (notifiedTables.has(subTableKey)) {
                return;
            }
            notifiedTables.add(subTableKey);
            listener(parent, subTableKey, parent.getSubTable(subTableKey));
        }, flags);
    }
    removeSubTableListener(guid) {
        this._instance.removeEntryListener(guid);
    }
    getSubTable(key) {
        return new NetworkTable(this._instance, this._pathWithSep + key);
    }
    containsKey(key) {
        return this.getEntry(key).exists();
    }
    containsSubTable(key) {
        const entries = this._instance.getEntries(this._pathWithSep + key + NT_PATH_SEPARATOR, network_table_instance_1.NetworkTableType.UNASSIGNED);
        return entries.length !== 0;
    }
    getKeys(types = network_table_instance_1.NetworkTableType.UNASSIGNED) {
        const keys = new Set();
        const prefixLen = this._path.length + 1;
        const entries = this._instance.getEntries(this._pathWithSep, types);
        entries.forEach(entry => {
            const relativeKey = entry.getName().substring(prefixLen);
            if (relativeKey.indexOf(NT_PATH_SEPARATOR) !== -1) {
                return;
            }
            keys.add(relativeKey);
            // Populate the entries as we go along
            if (!this._entries.has(relativeKey)) {
                this._entries.set(relativeKey, entry);
            }
        });
        return keys;
    }
    getSubTables() {
        const keys = new Set();
        const prefixLen = this._path.length + 1;
        const entries = this._instance.getEntries(this._pathWithSep, network_table_instance_1.NetworkTableType.UNASSIGNED);
        entries.forEach(entry => {
            const relativeKey = entry.getName().substring(prefixLen);
            const endSubTable = relativeKey.indexOf(NT_PATH_SEPARATOR);
            if (endSubTable === -1) {
                return;
            }
            keys.add(relativeKey.substring(0, endSubTable));
        });
        return keys;
    }
    delete(key) {
        this.getEntry(key).delete();
    }
    getPath() {
        return this._path;
    }
    saveEntries(filename) {
        throw new Error("Method Not Implemented");
    }
    loadEntries(filename) {
        throw new Error("Method not implemented");
    }
}
exports.default = NetworkTable;
//# sourceMappingURL=network-table.js.map