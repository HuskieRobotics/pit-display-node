"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toNetworkTableType = exports.toNTEntryType = exports.NetworkTableType = exports.ConnectionState = exports.OperatingMode = exports.EntryListenerFlags = exports.NT_PATH_SEPARATOR = void 0;
const uuid_1 = require("uuid");
const nt_entry_1 = require("../protocol/nt-entry");
const v3_nt_client_1 = __importDefault(require("../protocol/v3/v3-nt-client"));
const nt_types_1 = require("../protocol/nt-types");
const v3_nt_server_1 = __importDefault(require("../protocol/v3/v3-nt-server"));
const network_table_entry_1 = __importStar(require("./network-table-entry"));
const network_table_1 = __importDefault(require("./network-table"));
const network_table_value_1 = __importDefault(require("./network-table-value"));
const log_util_1 = __importStar(require("../utils/log-util"));
const DEFAULT_NT_PORT = 1735;
exports.NT_PATH_SEPARATOR = "/";
var EntryEventType;
(function (EntryEventType) {
    EntryEventType["ADD"] = "ADD";
    EntryEventType["UPDATE"] = "UPDATE";
    EntryEventType["DELETE"] = "DELETE";
    EntryEventType["FLAGS"] = "FLAGS";
})(EntryEventType || (EntryEventType = {}));
var EntryListenerFlags;
(function (EntryListenerFlags) {
    EntryListenerFlags[EntryListenerFlags["IMMEDIATE"] = 1] = "IMMEDIATE";
    EntryListenerFlags[EntryListenerFlags["LOCAL"] = 2] = "LOCAL";
    EntryListenerFlags[EntryListenerFlags["NEW"] = 4] = "NEW";
    EntryListenerFlags[EntryListenerFlags["DELETE"] = 8] = "DELETE";
    EntryListenerFlags[EntryListenerFlags["UPDATE"] = 16] = "UPDATE";
    EntryListenerFlags[EntryListenerFlags["FLAGS"] = 32] = "FLAGS";
})(EntryListenerFlags = exports.EntryListenerFlags || (exports.EntryListenerFlags = {}));
var OperatingMode;
(function (OperatingMode) {
    OperatingMode[OperatingMode["CLIENT"] = 0] = "CLIENT";
    OperatingMode[OperatingMode["SERVER"] = 1] = "SERVER";
    OperatingMode[OperatingMode["LOCAL"] = 2] = "LOCAL";
    OperatingMode[OperatingMode["UNCONFIGURED"] = 3] = "UNCONFIGURED";
})(OperatingMode = exports.OperatingMode || (exports.OperatingMode = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["OFFLINE"] = 0] = "OFFLINE";
    ConnectionState[ConnectionState["CONNECTING"] = 1] = "CONNECTING";
    ConnectionState[ConnectionState["ONLINE"] = 2] = "ONLINE";
})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
var NetworkTableType;
(function (NetworkTableType) {
    NetworkTableType[NetworkTableType["UNASSIGNED"] = 0] = "UNASSIGNED";
    NetworkTableType[NetworkTableType["BOOLEAN"] = 1] = "BOOLEAN";
    NetworkTableType[NetworkTableType["DOUBLE"] = 2] = "DOUBLE";
    NetworkTableType[NetworkTableType["STRING"] = 4] = "STRING";
    NetworkTableType[NetworkTableType["RAW"] = 8] = "RAW";
    NetworkTableType[NetworkTableType["BOOLEAN_ARRAY"] = 16] = "BOOLEAN_ARRAY";
    NetworkTableType[NetworkTableType["DOUBLE_ARRAY"] = 32] = "DOUBLE_ARRAY";
    NetworkTableType[NetworkTableType["STRING_ARRAY"] = 64] = "STRING_ARRAY";
    NetworkTableType[NetworkTableType["RPC"] = 128] = "RPC";
})(NetworkTableType = exports.NetworkTableType || (exports.NetworkTableType = {}));
;
function toNTEntryType(type) {
    switch (type) {
        case NetworkTableType.BOOLEAN:
            return nt_entry_1.NTEntryType.BOOLEAN;
        case NetworkTableType.BOOLEAN_ARRAY:
            return nt_entry_1.NTEntryType.BOOLEAN_ARRAY;
        case NetworkTableType.DOUBLE:
            return nt_entry_1.NTEntryType.DOUBLE;
        case NetworkTableType.DOUBLE_ARRAY:
            return nt_entry_1.NTEntryType.DOUBLE_ARRAY;
        case NetworkTableType.STRING:
            return nt_entry_1.NTEntryType.STRING;
        case NetworkTableType.STRING_ARRAY:
            return nt_entry_1.NTEntryType.STRING_ARRAY;
        case NetworkTableType.RAW:
            return nt_entry_1.NTEntryType.RAW;
        case NetworkTableType.RPC:
            return nt_entry_1.NTEntryType.RPC;
        default:
            throw new Error("Invalid conversion");
    }
}
exports.toNTEntryType = toNTEntryType;
function toNetworkTableType(type) {
    switch (type) {
        case nt_entry_1.NTEntryType.BOOLEAN:
            return NetworkTableType.BOOLEAN;
        case nt_entry_1.NTEntryType.BOOLEAN_ARRAY:
            return NetworkTableType.BOOLEAN_ARRAY;
        case nt_entry_1.NTEntryType.DOUBLE:
            return NetworkTableType.DOUBLE;
        case nt_entry_1.NTEntryType.DOUBLE_ARRAY:
            return NetworkTableType.DOUBLE_ARRAY;
        case nt_entry_1.NTEntryType.STRING:
            return NetworkTableType.STRING;
        case nt_entry_1.NTEntryType.STRING_ARRAY:
            return NetworkTableType.STRING_ARRAY;
        case nt_entry_1.NTEntryType.RAW:
            return NetworkTableType.RAW;
        case nt_entry_1.NTEntryType.RPC:
            return NetworkTableType.RPC;
    }
}
exports.toNetworkTableType = toNetworkTableType;
const DEFAULT_INSTANCE_IDENTIFIER = "NTCORE_DEFAULT_INSTANCE";
class NetworkTableInstance {
    constructor(guid) {
        this._logLevel = log_util_1.LogLevel.info;
        // Stores all the registered raw NTEntry objects
        // These represent actual, live data
        this._ntEntries = new Map();
        this._pendingNtEntries = new Map();
        // Map from NTEntry key => guid
        this._entryGuidMap = new Map();
        this._pendingEntryGuids = new Map();
        // Cache of NetworkTableEntry-s
        this._entries = new Map();
        // Cache of NetworkTable-s
        this._tables = new Map();
        this._ntParticipant = null;
        this._netIdentity = "NetworkTable";
        this._opMode = OperatingMode.UNCONFIGURED;
        this._connState = ConnectionState.OFFLINE;
        // Entry Listeners
        this._entryListeners = new Map();
        this._guid = guid;
        this._logger = log_util_1.default.getLogger("NTCORE");
        // Set up the NTEntryFunctions
        this._entryFuncs = {
            getLastChange: this._entryGetLastChange.bind(this),
            getType: this._entryGetType.bind(this),
            getValue: this._entryGetValue.bind(this),
            getBoolean: this._entryGetBoolean.bind(this),
            getBooleanArray: this._entryGetBooleanArray.bind(this),
            getString: this._entryGetString.bind(this),
            getStringArray: this._entryGetStringArray.bind(this),
            getDouble: this._entryGetDouble.bind(this),
            getDoubleArray: this._entryGetDoubleArray.bind(this),
            getRaw: this._entryGetRaw.bind(this),
            setBoolean: this._entrySetBoolean.bind(this),
            setBooleanArray: this._entrySetBooleanArray.bind(this),
            setDouble: this._entrySetDouble.bind(this),
            setDoubleArray: this._entrySetDoubleArray.bind(this),
            setString: this._entrySetString.bind(this),
            setStringArray: this._entrySetStringArray.bind(this),
            setRaw: this._entrySetRaw.bind(this),
            delete: this._entryDelete.bind(this),
            exists: this._entryExists.bind(this),
            getFlags: this._entryGetFlags.bind(this),
            setFlags: this._entrySetFlags.bind(this)
        };
    }
    static getDefault() {
        if (!this.s_instances.has(DEFAULT_INSTANCE_IDENTIFIER)) {
            this.s_instances.set(DEFAULT_INSTANCE_IDENTIFIER, new NetworkTableInstance(DEFAULT_INSTANCE_IDENTIFIER));
        }
        return this.s_instances.get(DEFAULT_INSTANCE_IDENTIFIER);
    }
    static create() {
        const guid = uuid_1.v4();
        const inst = new NetworkTableInstance(guid);
        this.s_instances.set(guid, inst);
        return inst;
    }
    setLogLevel(val) {
        let level = log_util_1.LogLevel.info;
        if (val === "error") {
            level = log_util_1.LogLevel.error;
        }
        else if (val === "warn") {
            level = log_util_1.LogLevel.warn;
        }
        else if (val === "info") {
            level = log_util_1.LogLevel.info;
        }
        else if (val === "verbose") {
            level = log_util_1.LogLevel.verbose;
        }
        else if (val === "debug") {
            level = log_util_1.LogLevel.debug;
        }
        else if (val === "silly") {
            level = log_util_1.LogLevel.silly;
        }
        this._logLevel = level;
        log_util_1.default.setLogLevel(level);
    }
    get guid() {
        return this._guid;
    }
    setNetworkIdentity(ident) {
        this._netIdentity = ident;
        if (this._ntParticipant) {
            this._ntParticipant.identifier = this._netIdentity;
        }
    }
    getEntry(key) {
        if (this._entryGuidMap.has(key)) {
            this._logger.debug("Found a previously cached entry for ", key);
            // We have a previously cached NetworkTableEntry
            const entryGuid = this._entryGuidMap.get(key);
            return this._entries.get(entryGuid).entry;
        }
        else if (this._pendingEntryGuids.has(key)) {
            this._logger.debug("Found a previously cached entry (pending) for ", key);
            // We have a previously cached PENDING NetworkTableEntry
            const entryGuid = this._pendingEntryGuids.get(key);
            return this._entries.get(entryGuid).entry;
        }
        else {
            this._logger.debug("Creating pending entry for ", key);
            // Create the entry accessor anyway
            const entryGuid = uuid_1.v4();
            const newEntry = new network_table_entry_1.default(this, key, entryGuid, this._entryFuncs);
            this._entries.set(entryGuid, {
                entry: newEntry,
                key,
                isPending: true
            });
            if (this._ntEntries.has(key)) {
                // If this is a live record, add the map from key to guid
                this._entryGuidMap.set(key, entryGuid);
                const entryInfo = this._entries.get(entryGuid);
                entryInfo.isPending = false;
            }
            else {
                // Not a live record yet, add to pending
                this._pendingEntryGuids.set(key, entryGuid);
            }
            return newEntry;
        }
    }
    getEntries(prefix, typeFilter = NetworkTableType.UNASSIGNED) {
        // Loop through all our current and pending entries
        const keys = [];
        const filter = (entryInfo) => {
            if (entryInfo.entry.name.indexOf(prefix) === 0) {
                if (typeFilter === NetworkTableType.UNASSIGNED) {
                    keys.push(entryInfo.entry.name);
                }
                else {
                    const type = toNetworkTableType(entryInfo.entry.type);
                    if ((type & typeFilter) !== 0) {
                        keys.push(entryInfo.entry.name);
                    }
                }
            }
        };
        this._ntEntries.forEach(entryInfo => {
            filter(entryInfo);
        });
        this._pendingNtEntries.forEach(entryInfo => {
            filter(entryInfo);
        });
        const results = keys.map(key => {
            return this.getEntry(key);
        });
        return results;
    }
    getTable(key) {
        let theKey = "";
        if (key === "" || key === exports.NT_PATH_SEPARATOR) {
            theKey = "";
        }
        else if (key.charAt(0) === exports.NT_PATH_SEPARATOR) {
            theKey = key;
        }
        else {
            theKey = exports.NT_PATH_SEPARATOR + key;
        }
        let table = this._tables.get(theKey);
        if (!table) {
            table = new network_table_1.default(this, theKey);
            this._tables.set(theKey, table);
        }
        return table;
    }
    addEntryListener(prefixOrEntry, listener, flags) {
        const listenerGuid = uuid_1.v4();
        let matchKey = "";
        let isPrefixMatch = false;
        if (prefixOrEntry instanceof network_table_entry_1.default) {
            matchKey = prefixOrEntry.getName();
            isPrefixMatch = false;
        }
        else {
            matchKey = prefixOrEntry;
            isPrefixMatch = true;
        }
        this._entryListeners.set(listenerGuid, {
            listener,
            flags,
            matchKey,
            isPrefixMatch
        });
        return listenerGuid;
    }
    removeEntryListener(guid) {
        this._entryListeners.delete(guid);
    }
    // Start this instance as a client
    startClient(hostAddr, port = DEFAULT_NT_PORT) {
        if (this._opMode !== OperatingMode.UNCONFIGURED && this._connState !== ConnectionState.OFFLINE) {
            this._logger.info("Cannot start client");
            return;
        }
        if (this._opMode !== OperatingMode.CLIENT || !this._ntParticipant) {
            if (this._ntParticipant) {
                this._ntParticipant.removeAllListeners();
            }
            this._logger.info("Creating new NT client");
            this._ntParticipant = new v3_nt_client_1.default({
                address: hostAddr,
                port,
                identifier: this._netIdentity
            });
            this._hookupNTEvents();
        }
        this._opMode = OperatingMode.CLIENT;
        this._ntParticipant.start();
    }
    stopClient() {
        if (this._opMode !== OperatingMode.CLIENT || this._connState === ConnectionState.OFFLINE) {
            return;
        }
        this._ntParticipant.stop();
        this._connState = ConnectionState.OFFLINE;
    }
    startServer(persistFile, port = DEFAULT_NT_PORT) {
        if (this._opMode !== OperatingMode.UNCONFIGURED && this._connState !== ConnectionState.OFFLINE) {
            return;
        }
        if (this._opMode !== OperatingMode.SERVER || !this._ntParticipant) {
            if (this._ntParticipant) {
                this._ntParticipant.removeAllListeners();
            }
            this._ntParticipant = new v3_nt_server_1.default({
                port,
                identifier: this._netIdentity
            });
            this._hookupNTEvents();
        }
        this._opMode = OperatingMode.SERVER;
        this._ntParticipant.start();
    }
    stopServer() {
        if (this._opMode !== OperatingMode.SERVER || this._connState === ConnectionState.OFFLINE) {
            return;
        }
        this._ntParticipant.stop();
        this._connState = ConnectionState.OFFLINE;
    }
    setServer(address, port = 1735) {
        if (this._opMode === OperatingMode.CLIENT && this._ntParticipant) {
            const client = this._ntParticipant;
            if (client.address !== address || client.port !== port) {
                client.setServerEndpoint({
                    address,
                    port
                });
            }
        }
    }
    _hookupNTEvents() {
        if (!this._ntParticipant) {
            return;
        }
        this._ntParticipant.on("connectionStateChanged", (oldState, newState) => {
            if (newState === nt_types_1.NTConnectionState.NTCONN_CONNECTED) {
                this._connState = ConnectionState.ONLINE;
                this._logger.debug("Flushing updates");
                // Flush any pending entries
                this._pendingNtEntries.forEach((value, key) => {
                    this._logger.debug("Flushing entry ", value.entry.name);
                    // TODO This is exactly the same logic as the code in onEntryAdded
                    // refactor into a helper function
                    switch (value.entry.type) {
                        case nt_entry_1.NTEntryType.BOOLEAN:
                            {
                                this._ntParticipant.setBoolean(key, value.entry.value.bool);
                            }
                            break;
                        case nt_entry_1.NTEntryType.BOOLEAN_ARRAY:
                            {
                                this._ntParticipant.setBooleanArray(key, value.entry.value.bool_array);
                            }
                            break;
                        case nt_entry_1.NTEntryType.DOUBLE:
                            {
                                this._ntParticipant.setDouble(key, value.entry.value.double);
                            }
                            break;
                        case nt_entry_1.NTEntryType.DOUBLE_ARRAY:
                            {
                                this._ntParticipant.setDoubleArray(key, value.entry.value.double_array);
                            }
                            break;
                        case nt_entry_1.NTEntryType.STRING:
                            {
                                this._ntParticipant.setString(key, value.entry.value.str);
                            }
                            break;
                        case nt_entry_1.NTEntryType.STRING_ARRAY:
                            {
                                this._ntParticipant.setStringArray(key, value.entry.value.str_array);
                            }
                            break;
                        case nt_entry_1.NTEntryType.RAW:
                            {
                                this._ntParticipant.setRaw(key, value.entry.value.raw);
                            }
                            break;
                    }
                });
                this._pendingNtEntries.clear();
            }
            else if (newState === nt_types_1.NTConnectionState.NTCONN_CONNECTING) {
                this._connState = ConnectionState.CONNECTING;
            }
            else {
                this._connState = ConnectionState.OFFLINE;
            }
        });
        this._ntParticipant.on("entryAdded", (evt) => {
            this._onEntryAdded(evt);
        });
        this._ntParticipant.on("entryUpdated", (evt) => {
            this._onEntryUpdated(evt);
        });
        this._ntParticipant.on("entryDeleted", (evt) => {
            this._onEntryDeleted(evt);
        });
        this._ntParticipant.on("entryFlagsUpdated", (evt) => {
            this._onEntryFlagsUpdated(evt);
        });
    }
    _onEntryAdded(evt) {
        this._logger.debug("ENTRY ADDED EVENT", evt);
        const key = evt.entry.name;
        // Add this to our collection
        if (this._ntEntries.has(key)) {
            // TODO what happens now?
        }
        this._ntEntries.set(key, {
            entry: Object.assign({}, evt.entry),
            lastUpdate: Date.now()
        });
        if (this._pendingEntryGuids.has(key)) {
            if (this._entryGuidMap.has(key)) {
                // ERROR!
                this._logger.warn("Error?? Already have an entry guid for this");
            }
            else {
                this._logger.debug("PROMOTING pending entry to full entry");
                this._entryGuidMap.set(key, this._pendingEntryGuids.get(key));
                this._pendingEntryGuids.delete(key);
                // If the update source was local, push
                if (evt.source === nt_types_1.NTEventUpdateSource.LOCAL && evt.entry.id === 0xFFFF) {
                    if (this._ntParticipant) {
                        this._logger.debug("Updating on remote");
                        // We need to set this on the NT Participant too
                        switch (evt.entry.type) {
                            case nt_entry_1.NTEntryType.BOOLEAN:
                                {
                                    this._ntParticipant.setBoolean(key, evt.entry.value.bool);
                                }
                                break;
                            case nt_entry_1.NTEntryType.BOOLEAN_ARRAY:
                                {
                                    this._ntParticipant.setBooleanArray(key, evt.entry.value.bool_array);
                                }
                                break;
                            case nt_entry_1.NTEntryType.DOUBLE:
                                {
                                    this._ntParticipant.setDouble(key, evt.entry.value.double);
                                }
                                break;
                            case nt_entry_1.NTEntryType.DOUBLE_ARRAY:
                                {
                                    this._ntParticipant.setDoubleArray(key, evt.entry.value.double_array);
                                }
                                break;
                            case nt_entry_1.NTEntryType.STRING:
                                {
                                    this._ntParticipant.setString(key, evt.entry.value.str);
                                }
                                break;
                            case nt_entry_1.NTEntryType.STRING_ARRAY:
                                {
                                    this._ntParticipant.setStringArray(key, evt.entry.value.str_array);
                                }
                                break;
                            case nt_entry_1.NTEntryType.RAW:
                                {
                                    this._ntParticipant.setRaw(key, evt.entry.value.raw);
                                }
                                break;
                        }
                    }
                }
            }
        }
        this._informListeners(EntryEventType.ADD, evt);
    }
    _onEntryUpdated(evt) {
        if (this._ntEntries.has(evt.entry.name)) {
            this._ntEntries.set(evt.entry.name, {
                entry: Object.assign({}, evt.entry),
                lastUpdate: Date.now()
            });
            this._informListeners(EntryEventType.UPDATE, evt);
        }
    }
    _onEntryFlagsUpdated(evt) {
        if (this._ntEntries.has(evt.entry.name)) {
            const entryInfo = this._ntEntries.get(evt.entry.name);
            entryInfo.entry.flags = Object.assign({}, evt.entry.flags);
            entryInfo.lastUpdate = Date.now();
            this._informListeners(EntryEventType.FLAGS, evt);
        }
    }
    _onEntryDeleted(evt) {
        this._ntEntries.delete(evt.entry.name);
        this._informListeners(EntryEventType.DELETE, evt);
    }
    _informListeners(evtType, evt) {
        this._entryListeners.forEach(listenerInfo => {
            // Handle Flags first
            const listenerFlags = listenerInfo.flags;
            // Skip if the event is local and we didn't request it
            if (evt.source === nt_types_1.NTEventUpdateSource.LOCAL && ((listenerFlags & EntryListenerFlags.LOCAL) === 0)) {
                return;
            }
            // Check the event type against the flags
            if (evtType === EntryEventType.ADD && ((listenerFlags & EntryListenerFlags.NEW) === 0)) {
                return;
            }
            else if (evtType === EntryEventType.UPDATE && ((listenerFlags & EntryListenerFlags.UPDATE) === 0)) {
                return;
            }
            else if (evtType === EntryEventType.DELETE && ((listenerFlags & EntryListenerFlags.DELETE) === 0)) {
                return;
            }
            else if (evtType === EntryEventType.FLAGS && ((listenerFlags & EntryListenerFlags.FLAGS) === 0)) {
                return;
            }
            // Reject based on prefix or exact match
            if (listenerInfo.isPrefixMatch) {
                if (evt.entry.name.indexOf(listenerInfo.matchKey) !== 0) {
                    return;
                }
            }
            else {
                if (evt.entry.name !== listenerInfo.matchKey) {
                    return;
                }
            }
            // Make the value
            let entryVal;
            switch (evt.entry.type) {
                case nt_entry_1.NTEntryType.BOOLEAN:
                    {
                        entryVal = network_table_value_1.default.makeBoolean(evt.entry.value.bool);
                    }
                    break;
                case nt_entry_1.NTEntryType.BOOLEAN_ARRAY:
                    {
                        entryVal = network_table_value_1.default.makeBooleanArray(evt.entry.value.bool_array);
                    }
                    break;
                case nt_entry_1.NTEntryType.DOUBLE:
                    {
                        entryVal = network_table_value_1.default.makeDouble(evt.entry.value.double);
                    }
                    break;
                case nt_entry_1.NTEntryType.DOUBLE_ARRAY:
                    {
                        entryVal = network_table_value_1.default.makeDoubleArray(evt.entry.value.double_array);
                    }
                    break;
                case nt_entry_1.NTEntryType.STRING:
                    {
                        entryVal = network_table_value_1.default.makeString(evt.entry.value.str);
                    }
                    break;
                case nt_entry_1.NTEntryType.STRING_ARRAY:
                    {
                        entryVal = network_table_value_1.default.makeStringArray(evt.entry.value.str_array);
                    }
                    break;
                case nt_entry_1.NTEntryType.RAW:
                    {
                        entryVal = network_table_value_1.default.makeRaw(evt.entry.value.raw);
                    }
                    break;
            }
            listenerInfo.listener(evt.entry.name, this.getEntry(evt.entry.name), entryVal, listenerInfo.flags);
        });
    }
    // NetworkTableEntry methods
    _entryGetLastChange(key) {
        let entryInfo;
        if (this._ntEntries.has(key)) {
            entryInfo = this._ntEntries.get(key);
        }
        else if (this._pendingNtEntries.has(key)) {
            entryInfo = this._pendingNtEntries.get(key);
        }
        if (entryInfo) {
            return entryInfo.lastUpdate;
        }
        return 0;
    }
    _entryGetType(key) {
        let entryInfo;
        if (this._ntEntries.has(key)) {
            entryInfo = this._ntEntries.get(key);
        }
        else if (this._pendingNtEntries.has(key)) {
            entryInfo = this._pendingNtEntries.get(key);
        }
        if (entryInfo) {
            return toNetworkTableType(entryInfo.entry.type);
        }
        return NetworkTableType.UNASSIGNED;
    }
    _entryGetValue(key) {
        let entryInfo;
        if (this._ntEntries.has(key)) {
            entryInfo = this._ntEntries.get(key);
        }
        else if (this._pendingNtEntries.has(key)) {
            entryInfo = this._pendingNtEntries.get(key);
        }
        if (entryInfo) {
            switch (entryInfo.entry.type) {
                case nt_entry_1.NTEntryType.BOOLEAN:
                    return network_table_value_1.default.makeBoolean(entryInfo.entry.value.bool);
                case nt_entry_1.NTEntryType.BOOLEAN_ARRAY:
                    return network_table_value_1.default.makeBooleanArray(entryInfo.entry.value.bool_array);
                case nt_entry_1.NTEntryType.DOUBLE:
                    return network_table_value_1.default.makeDouble(entryInfo.entry.value.double);
                case nt_entry_1.NTEntryType.DOUBLE_ARRAY:
                    return network_table_value_1.default.makeDoubleArray(entryInfo.entry.value.double_array);
                case nt_entry_1.NTEntryType.STRING:
                    return network_table_value_1.default.makeString(entryInfo.entry.value.str);
                case nt_entry_1.NTEntryType.STRING_ARRAY:
                    return network_table_value_1.default.makeStringArray(entryInfo.entry.value.str_array);
                case nt_entry_1.NTEntryType.RAW:
                    return network_table_value_1.default.makeRaw(entryInfo.entry.value.raw);
            }
        }
        return network_table_value_1.default.makeUnassigned();
    }
    _entryGetBoolean(key, defaultVal) {
        let entryInfo;
        if (this._ntEntries.has(key)) {
            entryInfo = this._ntEntries.get(key);
        }
        else if (this._pendingNtEntries.has(key)) {
            entryInfo = this._pendingNtEntries.get(key);
        }
        if (entryInfo) {
            if (entryInfo.entry.type === nt_entry_1.NTEntryType.BOOLEAN) {
                return entryInfo.entry.value.bool;
            }
        }
        return defaultVal;
    }
    _entryGetString(key, defaultVal) {
        let entryInfo;
        if (this._ntEntries.has(key)) {
            entryInfo = this._ntEntries.get(key);
        }
        else if (this._pendingNtEntries.has(key)) {
            entryInfo = this._pendingNtEntries.get(key);
        }
        if (entryInfo) {
            if (entryInfo.entry.type === nt_entry_1.NTEntryType.STRING) {
                return entryInfo.entry.value.str;
            }
        }
        return defaultVal;
    }
    _entryGetDouble(key, defaultVal) {
        let entryInfo;
        if (this._ntEntries.has(key)) {
            entryInfo = this._ntEntries.get(key);
        }
        else if (this._pendingNtEntries.has(key)) {
            entryInfo = this._pendingNtEntries.get(key);
        }
        if (entryInfo) {
            if (entryInfo.entry.type === nt_entry_1.NTEntryType.DOUBLE) {
                return entryInfo.entry.value.double;
            }
        }
        return defaultVal;
    }
    _entryGetBooleanArray(key, defaultVal) {
        let entryInfo;
        if (this._ntEntries.has(key)) {
            entryInfo = this._ntEntries.get(key);
        }
        else if (this._pendingNtEntries.has(key)) {
            entryInfo = this._pendingNtEntries.get(key);
        }
        if (entryInfo) {
            if (entryInfo.entry.type === nt_entry_1.NTEntryType.BOOLEAN_ARRAY) {
                return entryInfo.entry.value.bool_array;
            }
        }
        return defaultVal;
    }
    _entryGetStringArray(key, defaultVal) {
        let entryInfo;
        if (this._ntEntries.has(key)) {
            entryInfo = this._ntEntries.get(key);
        }
        else if (this._pendingNtEntries.has(key)) {
            entryInfo = this._pendingNtEntries.get(key);
        }
        if (entryInfo) {
            if (entryInfo.entry.type === nt_entry_1.NTEntryType.STRING_ARRAY) {
                return entryInfo.entry.value.str_array;
            }
        }
        return defaultVal;
    }
    _entryGetDoubleArray(key, defaultVal) {
        let entryInfo;
        if (this._ntEntries.has(key)) {
            entryInfo = this._ntEntries.get(key);
        }
        else if (this._pendingNtEntries.has(key)) {
            entryInfo = this._pendingNtEntries.get(key);
        }
        if (entryInfo) {
            if (entryInfo.entry.type === nt_entry_1.NTEntryType.DOUBLE_ARRAY) {
                return entryInfo.entry.value.double_array;
            }
        }
        return defaultVal;
    }
    _entryGetRaw(key, defaultVal) {
        let entryInfo;
        if (this._ntEntries.has(key)) {
            entryInfo = this._ntEntries.get(key);
        }
        else if (this._pendingNtEntries.has(key)) {
            entryInfo = this._pendingNtEntries.get(key);
        }
        if (entryInfo) {
            if (entryInfo.entry.type === nt_entry_1.NTEntryType.RAW) {
                return entryInfo.entry.value.raw;
            }
        }
        return defaultVal;
    }
    _entrySetBoolean(key, val) {
        if (!this._ntParticipant) {
            return this._insertPendingEntry(key, nt_entry_1.NTEntryType.BOOLEAN, { bool: val });
        }
        return this._ntParticipant.setBoolean(key, val);
    }
    _entrySetString(key, val) {
        if (!this._ntParticipant) {
            return this._insertPendingEntry(key, nt_entry_1.NTEntryType.STRING, { str: val });
        }
        return this._ntParticipant.setString(key, val);
    }
    _entrySetDouble(key, val) {
        if (!this._ntParticipant) {
            return this._insertPendingEntry(key, nt_entry_1.NTEntryType.DOUBLE, { double: val });
        }
        return this._ntParticipant.setDouble(key, val);
    }
    _entrySetBooleanArray(key, val) {
        if (!this._ntParticipant) {
            return this._insertPendingEntry(key, nt_entry_1.NTEntryType.BOOLEAN_ARRAY, { bool_array: val });
        }
        return this._ntParticipant.setBooleanArray(key, val);
    }
    _entrySetStringArray(key, val) {
        if (!this._ntParticipant) {
            return this._insertPendingEntry(key, nt_entry_1.NTEntryType.STRING_ARRAY, { str_array: val });
        }
        return this._ntParticipant.setStringArray(key, val);
    }
    _entrySetDoubleArray(key, val) {
        if (!this._ntParticipant) {
            return this._insertPendingEntry(key, nt_entry_1.NTEntryType.DOUBLE_ARRAY, { double_array: val });
        }
        return this._ntParticipant.setDoubleArray(key, val);
    }
    _entrySetRaw(key, val) {
        if (!this._ntParticipant) {
            return this._insertPendingEntry(key, nt_entry_1.NTEntryType.RAW, { raw: val });
        }
        return this._ntParticipant.setRaw(key, val);
    }
    _entryDelete(key) {
        if (!this._ntParticipant) {
            if (this._pendingNtEntries.has(key)) {
                this._pendingNtEntries.delete(key);
                return true;
            }
            return false;
        }
        return this._ntParticipant.deleteEntry(key);
    }
    _entryExists(key) {
        return this._ntEntries.has(key);
    }
    _entryGetFlags(key) {
        if (!this._ntEntries.has(key)) {
            return network_table_entry_1.NetworkTableEntryFlags.UNASSIGNED;
        }
        let result = network_table_entry_1.NetworkTableEntryFlags.UNASSIGNED;
        const entryInfo = this._ntEntries.get(key);
        if (entryInfo.entry.flags) {
            const flags = entryInfo.entry.flags;
            if (flags.persistent) {
                result |= network_table_entry_1.NetworkTableEntryFlags.PERSISTENT;
            }
        }
        return result;
    }
    _entrySetFlags(key, flags) {
        if (!this._ntParticipant) {
            return;
        }
        if (!this._ntEntries.has(key)) {
            return;
        }
        const entryFlags = {
            persistent: (flags & network_table_entry_1.NetworkTableEntryFlags.PERSISTENT) !== 0
        };
        this._ntParticipant.updateEntryFlags(key, entryFlags);
    }
    _insertPendingEntry(key, type, value) {
        // Typecheck
        if (!this._typecheckValue(type, value)) {
            return false;
        }
        if (!this._pendingNtEntries.has(key)) {
            this._pendingNtEntries.set(key, {
                lastUpdate: Date.now(),
                entry: {
                    name: key,
                    id: 0xFFFF,
                    seq: 0,
                    type,
                    value
                }
            });
            return true;
        }
        else {
            // There's an existing pending option, check the types
            const entryInfo = this._pendingNtEntries.get(key);
            if (entryInfo.entry.type !== type) {
                return false;
            }
            entryInfo.entry.value = value;
            return true;
        }
    }
    _typecheckValue(type, val) {
        switch (type) {
            case nt_entry_1.NTEntryType.BOOLEAN:
                return val.bool !== undefined;
            case nt_entry_1.NTEntryType.BOOLEAN_ARRAY:
                return val.bool_array !== undefined;
            case nt_entry_1.NTEntryType.DOUBLE:
                return val.double !== undefined;
            case nt_entry_1.NTEntryType.DOUBLE_ARRAY:
                return val.double_array !== undefined;
            case nt_entry_1.NTEntryType.STRING:
                return val.str !== undefined;
            case nt_entry_1.NTEntryType.STRING_ARRAY:
                return val.str_array !== undefined;
            case nt_entry_1.NTEntryType.RAW:
                return val.raw !== undefined;
            case nt_entry_1.NTEntryType.RPC:
                return val.rpc !== undefined;
        }
    }
}
exports.default = NetworkTableInstance;
// STATIC METHODS AND PROPERTIES
NetworkTableInstance.s_instances = new Map();
//# sourceMappingURL=network-table-instance.js.map