"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const v3_types_1 = require("../../protocol/v3/v3-types");
const v3_messages_1 = require("../../protocol/v3/v3-messages");
describe("NT V3 Messages", () => {
    it("should encode/decode KEEP ALIVE messages correctly", () => {
        const keepAliveBuf = v3_messages_1.keepAliveMessageToBuffer();
        const keepAliveMsg = v3_messages_1.keepAliveMessageFromBuffer(keepAliveBuf);
        expect(keepAliveMsg.newOffset).toBe(keepAliveBuf.length);
    });
    it("should encode/decode CLIENT HELLO messages correctly", () => {
        const expected = {
            type: v3_types_1.V3MessageType.CLIENT_HELLO,
            protocolMajor: 3,
            protocolMinor: 0,
            clientIdent: "foobar"
        };
        const clientHelloBuf = v3_messages_1.clientHelloMessageToBuffer(expected);
        const result = v3_messages_1.clientHelloMessageFromBuffer(clientHelloBuf);
        expect(result.message).toEqual(expected);
        expect(result.newOffset).toBe(clientHelloBuf.length);
    });
    it("should encode/decode PROTOCOL UNSUPPORTED messages correctly", () => {
        const expected = {
            type: v3_types_1.V3MessageType.PROTO_VERSION_UNSUPPORTED,
            serverSupportedProtocolMinor: 3,
            serverSupportedProtocolMajor: 0
        };
        const protoUnsupportedBuf = v3_messages_1.protoVersionUnsupportedMessageToBuffer(expected);
        const result = v3_messages_1.protoVersionUnsupportedMessageFromBuffer(protoUnsupportedBuf);
        expect(result.message).toEqual(expected);
        expect(result.newOffset).toBe(protoUnsupportedBuf.length);
    });
    it("should encode/decode SERVER HELLO COMPLETE messages correctly", () => {
        const serverHelloCompleteBuf = v3_messages_1.serverHelloCompleteMessageToBuffer();
        const serverHelloCompleteMsg = v3_messages_1.serverHelloCompleteMessageFromBuffer(serverHelloCompleteBuf);
        expect(serverHelloCompleteMsg.newOffset).toBe(serverHelloCompleteBuf.length);
    });
    it("should encode/decode SERVER HELLO messages correctly", () => {
        const expected = {
            type: v3_types_1.V3MessageType.SERVER_HELLO,
            clientPreviouslySeen: true,
            serverIdentity: "super cool NT server"
        };
        const serverHelloBuf = v3_messages_1.serverHelloMessageToBuffer(expected);
        const result = v3_messages_1.serverHelloMessageFromBuffer(serverHelloBuf);
        expect(result.message).toEqual(expected);
        expect(result.newOffset).toBe(serverHelloBuf.length);
    });
    it("should encode/decode CLIENT HELLO COMPLETE messages correctly", () => {
        const clientHelloCompleteBuf = v3_messages_1.clientHelloCompleteMessageToBuffer();
        const clientHelloCompleteMsg = v3_messages_1.clientHelloCompleteMessageFromBuffer(clientHelloCompleteBuf);
        expect(clientHelloCompleteMsg.newOffset).toBe(clientHelloCompleteBuf.length);
    });
    describe("EntryAssignment Messages", () => {
        it("should encode/decode BOOLEAN EntryAssignment messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                entryName: "/My/Super/Cool/Entry",
                entryType: v3_types_1.V3EntryType.BOOLEAN,
                entryId: 1234,
                entrySeq: 64,
                entryFlags: {
                    persistent: true
                },
                entryValue: {
                    bool: true
                }
            };
            const msgBuf = v3_messages_1.entryAssignmentMessageToBuffer(expected);
            const result = v3_messages_1.entryAssignmentMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode DOUBLE EntryAssignment messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                entryName: "/My/Super/Cool/Entry",
                entryType: v3_types_1.V3EntryType.DOUBLE,
                entryId: 1234,
                entrySeq: 64,
                entryFlags: {
                    persistent: true
                },
                entryValue: {
                    double: 1.234
                }
            };
            const msgBuf = v3_messages_1.entryAssignmentMessageToBuffer(expected);
            const result = v3_messages_1.entryAssignmentMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode STRING EntryAssignment messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                entryName: "/My/Super/Cool/Entry",
                entryType: v3_types_1.V3EntryType.STRING,
                entryId: 1234,
                entrySeq: 64,
                entryFlags: {
                    persistent: true
                },
                entryValue: {
                    str: "The quick brown fox"
                }
            };
            const msgBuf = v3_messages_1.entryAssignmentMessageToBuffer(expected);
            const result = v3_messages_1.entryAssignmentMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode BOOLEAN ARRAY EntryAssignment messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                entryName: "/My/Super/Cool/Entry",
                entryType: v3_types_1.V3EntryType.BOOLEAN_ARRAY,
                entryId: 1234,
                entrySeq: 64,
                entryFlags: {
                    persistent: true
                },
                entryValue: {
                    bool_array: [true, false, true, false, false, true]
                }
            };
            const msgBuf = v3_messages_1.entryAssignmentMessageToBuffer(expected);
            const result = v3_messages_1.entryAssignmentMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode DOUBLE ARRAY EntryAssignment messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                entryName: "/My/Super/Cool/Entry",
                entryType: v3_types_1.V3EntryType.DOUBLE_ARRAY,
                entryId: 1234,
                entrySeq: 64,
                entryFlags: {
                    persistent: true
                },
                entryValue: {
                    double_array: [1.234, 2, 1, 3.14]
                }
            };
            const msgBuf = v3_messages_1.entryAssignmentMessageToBuffer(expected);
            const result = v3_messages_1.entryAssignmentMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode STRING ARRAY EntryAssignment messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                entryName: "/My/Super/Cool/Entry",
                entryType: v3_types_1.V3EntryType.STRING_ARRAY,
                entryId: 1234,
                entrySeq: 64,
                entryFlags: {
                    persistent: true
                },
                entryValue: {
                    str_array: ["the", "quick brown", "", "fox"]
                }
            };
            const msgBuf = v3_messages_1.entryAssignmentMessageToBuffer(expected);
            const result = v3_messages_1.entryAssignmentMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode RAW EntryAssignment messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                entryName: "/My/Super/Cool/Entry",
                entryType: v3_types_1.V3EntryType.RAW,
                entryId: 1234,
                entrySeq: 64,
                entryFlags: {
                    persistent: true
                },
                entryValue: {
                    raw: Buffer.from([1, 2, 3, 4, 0xDE, 0xAD, 0xBE, 0xEF])
                }
            };
            const msgBuf = v3_messages_1.entryAssignmentMessageToBuffer(expected);
            const result = v3_messages_1.entryAssignmentMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        // TODO need to tweak the RPC stuff
        it("should encode/decode RPC EntryAssignment messages correctly", () => {
            const rpcDef = {
                name: "My RPC",
                parameters: [
                    {
                        name: "Param1",
                        type: v3_types_1.V3EntryType.BOOLEAN,
                        value: {
                            bool: false
                        }
                    },
                    {
                        name: "Param2",
                        type: v3_types_1.V3EntryType.STRING,
                        value: {
                            str: "FooBar"
                        }
                    }
                ],
                results: [
                    {
                        name: "Result1",
                        type: v3_types_1.V3EntryType.DOUBLE,
                        value: {}
                    }
                ]
            };
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
                entryName: "/My/Super/Cool/Entry",
                entryType: v3_types_1.V3EntryType.RPC,
                entryId: 1234,
                entrySeq: 64,
                entryFlags: {
                    persistent: true
                },
                entryValue: {
                    rpc: rpcDef
                }
            };
            const msgBuf = v3_messages_1.entryAssignmentMessageToBuffer(expected);
            const result = v3_messages_1.entryAssignmentMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
    });
    describe("EntryUpdate Messages", () => {
        it("should encode/decode BOOLEAN EntryUpdate messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_UPDATE,
                entryId: 4321,
                entrySeq: 128,
                entryType: v3_types_1.V3EntryType.BOOLEAN,
                entryValue: {
                    bool: false
                }
            };
            const msgBuf = v3_messages_1.entryUpdateMessageToBuffer(expected);
            const result = v3_messages_1.entryUpdateMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode DOUBLE EntryUpdate messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_UPDATE,
                entryId: 4321,
                entrySeq: 128,
                entryType: v3_types_1.V3EntryType.DOUBLE,
                entryValue: {
                    double: 3.14
                }
            };
            const msgBuf = v3_messages_1.entryUpdateMessageToBuffer(expected);
            const result = v3_messages_1.entryUpdateMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode STRING EntryUpdate messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_UPDATE,
                entryId: 4321,
                entrySeq: 128,
                entryType: v3_types_1.V3EntryType.STRING,
                entryValue: {
                    str: "foo to the bar"
                }
            };
            const msgBuf = v3_messages_1.entryUpdateMessageToBuffer(expected);
            const result = v3_messages_1.entryUpdateMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode BOOLEAN ARRAY EntryUpdate messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_UPDATE,
                entryId: 4321,
                entrySeq: 128,
                entryType: v3_types_1.V3EntryType.BOOLEAN_ARRAY,
                entryValue: {
                    bool_array: [true, false, false, true]
                }
            };
            const msgBuf = v3_messages_1.entryUpdateMessageToBuffer(expected);
            const result = v3_messages_1.entryUpdateMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode DOUBLE ARRAY EntryUpdate messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_UPDATE,
                entryId: 4321,
                entrySeq: 128,
                entryType: v3_types_1.V3EntryType.DOUBLE_ARRAY,
                entryValue: {
                    double_array: [3.14, 0, 1.25, 2.456]
                }
            };
            const msgBuf = v3_messages_1.entryUpdateMessageToBuffer(expected);
            const result = v3_messages_1.entryUpdateMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode STRING ARRAY EntryUpdate messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_UPDATE,
                entryId: 4321,
                entrySeq: 128,
                entryType: v3_types_1.V3EntryType.STRING_ARRAY,
                entryValue: {
                    str_array: ["", "meow", "my cat is weird"]
                }
            };
            const msgBuf = v3_messages_1.entryUpdateMessageToBuffer(expected);
            const result = v3_messages_1.entryUpdateMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
        it("should encode/decode RAW EntryUpdate messages correctly", () => {
            const expected = {
                type: v3_types_1.V3MessageType.ENTRY_UPDATE,
                entryId: 4321,
                entrySeq: 128,
                entryType: v3_types_1.V3EntryType.RAW,
                entryValue: {
                    raw: Buffer.from([0xDE, 0xAD, 0xBE, 0xEF, 12, 34, 56])
                }
            };
            const msgBuf = v3_messages_1.entryUpdateMessageToBuffer(expected);
            const result = v3_messages_1.entryUpdateMessageFromBuffer(msgBuf);
            expect(result.message).toEqual(expected);
            expect(result.newOffset).toBe(msgBuf.length);
        });
    });
    it("should encode/decode ENTRY FLAGS UPDATE messages correctly", () => {
        const expected = {
            type: v3_types_1.V3MessageType.ENTRY_FLAGS_UPDATE,
            entryId: 2456,
            entryFlags: {
                persistent: false
            }
        };
        const msgBuf = v3_messages_1.entryFlagsUpdateMessageToBuffer(expected);
        const result = v3_messages_1.entryFlagsUpdateMessageFromBuffer(msgBuf);
        expect(result.message).toEqual(expected);
        expect(result.newOffset).toBe(msgBuf.length);
    });
    it("should encode/decode DELETE ENTRY messages correctly", () => {
        const expected = {
            type: v3_types_1.V3MessageType.ENTRY_DELETE,
            entryId: 2468
        };
        const msgBuf = v3_messages_1.entryDeleteMessageToBuffer(expected);
        const result = v3_messages_1.entryDeleteMessageFromBuffer(msgBuf);
        expect(result.message).toEqual(expected);
        expect(result.newOffset).toBe(msgBuf.length);
    });
    it("should encode/decode CLEAR ALL ENTRIES messages correctly", () => {
        const msgBuf = v3_messages_1.clearAllEntriesMessageToBuffer();
        const result = v3_messages_1.clearAllEntriesMessageFromBuffer(msgBuf);
        expect(result.newOffset).toBe(msgBuf.length);
    });
});
//# sourceMappingURL=messages-test.js.map