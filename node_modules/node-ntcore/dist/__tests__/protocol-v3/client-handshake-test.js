"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const v3_types_1 = require("../../protocol/v3/v3-types");
const v3_messages_1 = require("../../protocol/v3/v3-messages");
const v3_nt_client_1 = require("../../protocol/v3/v3-nt-client");
const log_util_1 = __importDefault(require("../../utils/log-util"));
describe("V3 Client Handshake Manager", () => {
    it("should perform the handshake correctly", (done) => __awaiter(void 0, void 0, void 0, function* () {
        let serverBuffers = [];
        function toServer(data) {
            serverBuffers.push(data);
            return Promise.resolve();
        }
        const handshakeManager = new v3_nt_client_1.V3ClientHandshakeManager("foo", toServer, log_util_1.default.getLogger("TEST"));
        handshakeManager.beginHandshake();
        expect(serverBuffers.length).toBe(1);
        expect(serverBuffers[0]).toEqual(v3_messages_1.clientHelloMessageToBuffer({
            type: v3_types_1.V3MessageType.CLIENT_HELLO,
            clientIdent: "foo",
            protocolMajor: 3,
            protocolMinor: 0
        }));
        // Get rid of the existing buffer
        serverBuffers.shift();
        const waitForServerHello = new Promise(resolve => {
            console.log("Setting up event listener");
            const handler = (oldState, newState) => {
                if (newState === v3_types_1.V3ClientHandshakeState.V3HS_AWAIT_SERVER_ENTRIES) {
                    handshakeManager.off("stateChange", handler);
                    resolve();
                }
            };
            handshakeManager.on("stateChange", handler);
        });
        let serverHelloMsg = {
            type: v3_types_1.V3MessageType.SERVER_HELLO,
            serverIdentity: "foo-server",
            clientPreviouslySeen: false
        };
        handshakeManager.handleMessage(serverHelloMsg);
        yield waitForServerHello;
        const entryAssignmentMsg1 = {
            type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
            entryName: "/my/awesome/boolean field",
            entryId: 1234,
            entrySeq: 1,
            entryFlags: { persistent: false },
            entryType: v3_types_1.V3EntryType.BOOLEAN,
            entryValue: {
                bool: true
            }
        };
        handshakeManager.handleMessage(entryAssignmentMsg1);
        const entryAssignmentMsg2 = {
            type: v3_types_1.V3MessageType.ENTRY_ASSIGNMENT,
            entryName: "/my/awesome/double array field",
            entryId: 1234,
            entrySeq: 1,
            entryFlags: { persistent: false },
            entryType: v3_types_1.V3EntryType.DOUBLE_ARRAY,
            entryValue: {
                double_array: [1, 2, 3.14, 4.89]
            }
        };
        handshakeManager.handleMessage(entryAssignmentMsg2);
        // Set up the wait for SERVER HELLO COMPLETE
        const waitForServerHelloComplete = new Promise(resolve => {
            const handler = (oldState, newState) => {
                if (newState === v3_types_1.V3ClientHandshakeState.V3HS_COMPLETE) {
                    handshakeManager.off("stateChange", handler);
                    resolve();
                }
            };
            handshakeManager.on("stateChange", handler);
        });
        const serverHelloCompleteMsg = {
            type: v3_types_1.V3MessageType.SERVER_HELLO_COMPLETE
        };
        handshakeManager.handleMessage(serverHelloCompleteMsg);
        yield waitForServerHelloComplete;
        done();
    }));
});
//# sourceMappingURL=client-handshake-test.js.map