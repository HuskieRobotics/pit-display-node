"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(require("net"));
const rr_socket_1 = __importDefault(require("../transport/rr-socket"));
describe("RRSocket", () => {
    it("should not attempt to connect when setting address/port while disconnected", (done) => {
        const client = new rr_socket_1.default();
        client.on("close", () => {
            throw new Error("Should not have fired 'close' event");
        });
        client.address = "localhost";
        client.port = 8080;
        done();
    });
    it("should connect and disconnect cleanly", (done) => __awaiter(void 0, void 0, void 0, function* () {
        const events = [];
        let serverPeer;
        const server = net_1.default.createServer(socket => {
            serverPeer = socket;
            events.push("server-connect");
        });
        server.listen(2021);
        const client = new rr_socket_1.default({
            address: "localhost",
            port: 2021,
            ident: "test-1"
        });
        client.on("connected", () => {
            events.push("connected");
            // Once we're connected, disconnect
            client.disconnect();
        });
        client.on("data", () => {
            events.push("data");
        });
        client.on("close", () => {
            events.push("close");
            expect(events).toEqual(["server-connect", "connected", "close"]);
            server.close(() => {
                done();
            });
        });
        client.connect();
    }));
    it("should attempt reconnection if the server is unavailable", (done) => __awaiter(void 0, void 0, void 0, function* () {
        const events = [];
        const client = new rr_socket_1.default({
            address: "localhost",
            port: 2022,
            reconnectDelay: 1000,
            ident: "test-2"
        });
        client.on("connected", () => {
            events.push("connected");
        });
        client.on("close", () => {
            events.push("close");
        });
        client.on("reconnectAttempt", () => {
            events.push("reconnectAttempt");
        });
        client.connect();
        setTimeout(() => {
            client.disconnect();
            expect(events).toEqual(["reconnectAttempt", "reconnectAttempt", "reconnectAttempt"]);
            done();
        }, 3500);
    }));
    it("should attempt reconnection if the server closes the connection", (done) => __awaiter(void 0, void 0, void 0, function* () {
        const events = [];
        const client = new rr_socket_1.default({
            address: "localhost",
            port: 2023,
            ident: "test-3"
        });
        let numClients = 0;
        const server = net_1.default.createServer(socket => {
            events.push("server-connect");
            numClients++;
            if (numClients === 1) {
                // Disconnect the first socket
                socket.destroy();
            }
            else if (numClients === 2) {
                setTimeout(() => {
                    client.disconnect();
                }, 500);
            }
        });
        server.listen(2023);
        client.on("connected", () => {
            events.push("connected");
        });
        client.on("close", () => {
            events.push("close");
            if (numClients === 2) {
                expect(events).toEqual([
                    "server-connect",
                    "connected",
                    "close",
                    "reconnectAttempt",
                    "server-connect",
                    "connected",
                    "close"
                ]);
                server.close(() => {
                    done();
                });
            }
        });
        client.on("reconnectAttempt", () => {
            events.push("reconnectAttempt");
        });
        client.connect();
    }));
    it("should handle reconnects to different servers", (done) => __awaiter(void 0, void 0, void 0, function* () {
        const events = [];
        const buffers = [];
        let numConnections = 0;
        const server1 = net_1.default.createServer(socket => {
            events.push("server1-connect");
            socket.write("abc");
        });
        const server2 = net_1.default.createServer(socket => {
            events.push("server2-connect");
            socket.write("def");
        });
        server1.listen(2024);
        server2.listen(2025);
        const client = new rr_socket_1.default({
            address: "localhost",
            port: 2024,
            ident: "test-4"
        });
        client.on("data", (data) => {
            buffers.push(data);
        });
        client.on("connected", () => {
            numConnections++;
            if (numConnections === 1) {
                // Switch ports to the other server
                setTimeout(() => {
                    client.port = 2025;
                }, 500);
            }
            else if (numConnections === 2) {
                setTimeout(() => {
                    client.port = 2024;
                }, 500);
            }
            else if (numConnections === 3) {
                setTimeout(() => {
                    const result = Buffer.concat(buffers);
                    expect(result).toEqual(Buffer.from("abcdefabc"));
                    client.disconnect();
                    server1.close(() => {
                        server2.close(() => {
                            done();
                        });
                    });
                }, 500);
            }
        });
        client.connect();
    }));
    it("should connect when a server eventually starts up", (done) => __awaiter(void 0, void 0, void 0, function* () {
        const client = new rr_socket_1.default({
            address: "localhost",
            port: 2026,
            reconnectDelay: 500,
            ident: "test-5"
        });
        const server = net_1.default.createServer();
        let reconnectCount = 0;
        client.on("connected", () => {
            client.disconnect();
            server.close(() => {
                expect(reconnectCount).toBeGreaterThan(2);
                done();
            });
        });
        client.on("reconnectAttempt", () => {
            reconnectCount++;
        });
        client.connect();
        setTimeout(() => {
            server.listen(2026);
        }, 3000);
    }));
});
//# sourceMappingURL=rr-socket-test.js.map